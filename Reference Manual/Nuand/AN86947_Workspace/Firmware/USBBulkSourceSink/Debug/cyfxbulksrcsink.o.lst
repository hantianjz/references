   1              		.cpu arm926ej-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 6
  10              		.eabi_attribute 18, 4
  11              		.file	"cyfxbulksrcsink.c"
  19              	.Ltext0:
  20              		.cfi_sections	.debug_frame
  21              		.comm	bulkSrcSinkAppThread,168,4
  22              		.comm	glChHandleBulkSink,160,4
  23              		.comm	glChHandleBulkSrc,160,4
  24              		.global	glIsApplnActive
  25              		.bss
  26              		.align	2
  29              	glIsApplnActive:
  30 0000 00000000 		.space	4
  31              		.global	glDMARxCount
  32              		.align	2
  35              	glDMARxCount:
  36 0004 00000000 		.space	4
  37              		.global	glDMATxCount
  38              		.align	2
  41              	glDMATxCount:
  42 0008 00000000 		.space	4
  43              		.global	glDataTransStarted
  44              		.align	2
  47              	glDataTransStarted:
  48 000c 00000000 		.space	4
  49              		.global	StandbyModeEnable
  50              		.align	2
  53              	StandbyModeEnable:
  54 0010 00000000 		.space	4
  55              		.global	TriggerStandbyMode
  56              		.align	2
  59              	TriggerStandbyMode:
  60 0014 00000000 		.space	4
  61              		.global	glForceLinkU2
  62              		.align	2
  65              	glForceLinkU2:
  66 0018 00000000 		.space	4
  67              		.global	glEp0StatCount
  68              		.align	2
  71              	glEp0StatCount:
  72 001c 00000000 		.space	4
  73              		.comm	glEp0Buffer,32,32
  74              		.comm	glBulkLpEvent,40,4
  75              		.comm	gl_setupdat0,4,4
  76              		.comm	gl_setupdat1,4,4
  77              		.global	gl_UsbLogBuffer
  78              		.align	2
  81              	gl_UsbLogBuffer:
  82 0020 00000000 		.space	4
  83              		.text
  84              		.align	2
  85              		.global	CyFxAppErrorHandler
  87              	CyFxAppErrorHandler:
  88              	.LFB0:
  89              		.file 1 "../cyfxbulksrcsink.c"
   1:../cyfxbulksrcsink.c **** /*
   2:../cyfxbulksrcsink.c ****  ## Cypress USB 3.0 Platform source file (cyfxbulksrcsink.c)
   3:../cyfxbulksrcsink.c ****  ## ===========================
   4:../cyfxbulksrcsink.c ****  ##
   5:../cyfxbulksrcsink.c ****  ##  Copyright Cypress Semiconductor Corporation, 2010-2011,
   6:../cyfxbulksrcsink.c ****  ##  All Rights Reserved
   7:../cyfxbulksrcsink.c ****  ##  UNPUBLISHED, LICENSED SOFTWARE.
   8:../cyfxbulksrcsink.c ****  ##
   9:../cyfxbulksrcsink.c ****  ##  CONFIDENTIAL AND PROPRIETARY INFORMATION
  10:../cyfxbulksrcsink.c ****  ##  WHICH IS THE PROPERTY OF CYPRESS.
  11:../cyfxbulksrcsink.c ****  ##
  12:../cyfxbulksrcsink.c ****  ##  Use of this file is governed
  13:../cyfxbulksrcsink.c ****  ##  by the license agreement included in the file
  14:../cyfxbulksrcsink.c ****  ##
  15:../cyfxbulksrcsink.c ****  ##     <install>/license/license.txt
  16:../cyfxbulksrcsink.c ****  ##
  17:../cyfxbulksrcsink.c ****  ##  where <install> is the Cypress software
  18:../cyfxbulksrcsink.c ****  ##  installation root directory path.
  19:../cyfxbulksrcsink.c ****  ##
  20:../cyfxbulksrcsink.c ****  ## ===========================
  21:../cyfxbulksrcsink.c **** */
  22:../cyfxbulksrcsink.c **** 
  23:../cyfxbulksrcsink.c **** /* This file illustrates the bulk source sink application example using the DMA MANUAL_IN
  24:../cyfxbulksrcsink.c ****    and DMA MANUAL_OUT mode */
  25:../cyfxbulksrcsink.c **** 
  26:../cyfxbulksrcsink.c **** /*
  27:../cyfxbulksrcsink.c ****    This example illustrates USB endpoint data source and data sink mechanism. The example
  28:../cyfxbulksrcsink.c ****    comprises of vendor class USB enumeration descriptors with 2 bulk endpoints. A bulk OUT
  29:../cyfxbulksrcsink.c ****    endpoint acts as the producer of data and acts as the sink to the host. A bulk IN endpoint
  30:../cyfxbulksrcsink.c ****    acts as the consumer of data and acts as the source to the host.
  31:../cyfxbulksrcsink.c **** 
  32:../cyfxbulksrcsink.c ****    The data source and sink is achieved with the help of a DMA MANUAL IN channel and a DMA
  33:../cyfxbulksrcsink.c ****    MANUAL OUT channel. A DMA MANUAL IN channel is created between the producer USB bulk
  34:../cyfxbulksrcsink.c ****    endpoint and the CPU. A DMA MANUAL OUT channel is created between the CPU and the consumer
  35:../cyfxbulksrcsink.c ****    USB bulk endpoint. Data is received in the IN channel DMA buffer from the host through the
  36:../cyfxbulksrcsink.c ****    producer endpoint. CPU is signalled of the data reception using DMA callbacks. The CPU
  37:../cyfxbulksrcsink.c ****    discards this buffer. This leads to the sink mechanism. A constant patern data is loaded
  38:../cyfxbulksrcsink.c ****    onto the OUT Channel DMA buffer whenever the buffer is available. CPU issues commit of
  39:../cyfxbulksrcsink.c ****    the DMA data transfer to the consumer endpoint which then gets transferred to the host.
  40:../cyfxbulksrcsink.c ****    This leads to a constant source mechanism.
  41:../cyfxbulksrcsink.c **** 
  42:../cyfxbulksrcsink.c ****    The DMA buffer size is defined based on the USB speed. 64 for full speed, 512 for high speed
  43:../cyfxbulksrcsink.c ****    and 1024 for super speed. CY_FX_BULKSRCSINK_DMA_BUF_COUNT in the header file defines the
  44:../cyfxbulksrcsink.c ****    number of DMA buffers.
  45:../cyfxbulksrcsink.c ****    
  46:../cyfxbulksrcsink.c ****    For performance optimizations refer the readme.txt
  47:../cyfxbulksrcsink.c ****  */
  48:../cyfxbulksrcsink.c **** 
  49:../cyfxbulksrcsink.c **** #include "cyu3system.h"
  50:../cyfxbulksrcsink.c **** #include "cyu3os.h"
  51:../cyfxbulksrcsink.c **** #include "cyu3dma.h"
  52:../cyfxbulksrcsink.c **** #include "cyu3error.h"
  53:../cyfxbulksrcsink.c **** #include "cyfxbulksrcsink.h"
  54:../cyfxbulksrcsink.c **** #include "cyu3usb.h"
  55:../cyfxbulksrcsink.c **** #include "cyu3uart.h"
  56:../cyfxbulksrcsink.c **** #include "cyu3gpio.h"
  57:../cyfxbulksrcsink.c **** #include "cyu3utils.h"
  58:../cyfxbulksrcsink.c **** 
  59:../cyfxbulksrcsink.c **** CyU3PThread     bulkSrcSinkAppThread;	 /* Application thread structure */
  60:../cyfxbulksrcsink.c **** CyU3PDmaChannel glChHandleBulkSink;      /* DMA MANUAL_IN channel handle.          */
  61:../cyfxbulksrcsink.c **** CyU3PDmaChannel glChHandleBulkSrc;       /* DMA MANUAL_OUT channel handle.         */
  62:../cyfxbulksrcsink.c **** 
  63:../cyfxbulksrcsink.c **** CyBool_t glIsApplnActive = CyFalse;      /* Whether the source sink application is active or not. *
  64:../cyfxbulksrcsink.c **** uint32_t glDMARxCount = 0;               /* Counter to track the number of buffers received. */
  65:../cyfxbulksrcsink.c **** uint32_t glDMATxCount = 0;               /* Counter to track the number of buffers transmitted. */
  66:../cyfxbulksrcsink.c **** CyBool_t glDataTransStarted = CyFalse;   /* Whether DMA transfer has been started after enumeration
  67:../cyfxbulksrcsink.c **** CyBool_t StandbyModeEnable  = CyFalse;   /* Whether standby mode entry is enabled. */
  68:../cyfxbulksrcsink.c **** CyBool_t TriggerStandbyMode = CyFalse;   /* Request to initiate standby entry. */
  69:../cyfxbulksrcsink.c **** CyBool_t glForceLinkU2      = CyFalse;   /* Whether the device should try to initiate U2 mode. */
  70:../cyfxbulksrcsink.c **** 
  71:../cyfxbulksrcsink.c **** volatile uint32_t glEp0StatCount = 0;           /* Number of EP0 status events received. */
  72:../cyfxbulksrcsink.c **** uint8_t glEp0Buffer[32] __attribute__ ((aligned (32))); /* Local buffer used for vendor command han
  73:../cyfxbulksrcsink.c **** 
  74:../cyfxbulksrcsink.c **** /* Control request related variables. */
  75:../cyfxbulksrcsink.c **** CyU3PEvent glBulkLpEvent;       /* Event group used to signal the thread that there is a pending re
  76:../cyfxbulksrcsink.c **** uint32_t   gl_setupdat0;        /* Variable that holds the setupdat0 value (bmRequestType, bRequest
  77:../cyfxbulksrcsink.c **** uint32_t   gl_setupdat1;        /* Variable that holds the setupdat1 value (wIndex and wLength). */
  78:../cyfxbulksrcsink.c **** #define CYFX_USB_CTRL_TASK      (1 << 0)        /* Event that indicates that there is a pending USB
  79:../cyfxbulksrcsink.c **** #define CYFX_USB_HOSTWAKE_TASK  (1 << 1)        /* Event that indicates the a Remote Wake should be
  80:../cyfxbulksrcsink.c **** 
  81:../cyfxbulksrcsink.c **** /* Buffer used for USB event logs. */
  82:../cyfxbulksrcsink.c **** uint8_t *gl_UsbLogBuffer = NULL;
  83:../cyfxbulksrcsink.c **** #define CYFX_USBLOG_SIZE        (0x1000)
  84:../cyfxbulksrcsink.c **** 
  85:../cyfxbulksrcsink.c **** /* GPIO used for testing IO state retention when switching from boot firmware to full firmware. */
  86:../cyfxbulksrcsink.c **** #define FX3_GPIO_TEST_OUT               (50)
  87:../cyfxbulksrcsink.c **** #define FX3_GPIO_TO_LOFLAG(gpio)        (1 << (gpio))
  88:../cyfxbulksrcsink.c **** #define FX3_GPIO_TO_HIFLAG(gpio)        (1 << ((gpio) - 32))
  89:../cyfxbulksrcsink.c **** 
  90:../cyfxbulksrcsink.c **** 
  91:../cyfxbulksrcsink.c **** /* Application Error Handler */
  92:../cyfxbulksrcsink.c **** void
  93:../cyfxbulksrcsink.c **** CyFxAppErrorHandler (
  94:../cyfxbulksrcsink.c ****         CyU3PReturnStatus_t apiRetStatus    /* API return status */
  95:../cyfxbulksrcsink.c ****         )
  96:../cyfxbulksrcsink.c **** {
  90              		.loc 1 96 0
  91              		.cfi_startproc
  92              		@ args = 0, pretend = 0, frame = 8
  93              		@ frame_needed = 1, uses_anonymous_args = 0
  94 0000 00482DE9 		stmfd	sp!, {fp, lr}
  95              	.LCFI0:
  96              		.cfi_def_cfa_offset 8
  97 0004 04B08DE2 		add	fp, sp, #4
  98              		.cfi_offset 14, -4
  99              		.cfi_offset 11, -8
 100              	.LCFI1:
 101              		.cfi_def_cfa 11, 4
 102 0008 08D04DE2 		sub	sp, sp, #8
 103 000c 08000BE5 		str	r0, [fp, #-8]
 104              	.L2:
  97:../cyfxbulksrcsink.c ****     /* Application failed with the error code apiRetStatus */
  98:../cyfxbulksrcsink.c **** 
  99:../cyfxbulksrcsink.c ****     /* Add custom debug or recovery actions here */
 100:../cyfxbulksrcsink.c **** 
 101:../cyfxbulksrcsink.c ****     /* Loop Indefinitely */
 102:../cyfxbulksrcsink.c ****     for (;;)
 103:../cyfxbulksrcsink.c ****     {
 104:../cyfxbulksrcsink.c ****         /* Thread sleep : 100 ms */
 105:../cyfxbulksrcsink.c ****         CyU3PThreadSleep (100);
 105              		.loc 1 105 0 discriminator 1
 106 0010 6400A0E3 		mov	r0, #100
 107 0014 FEFFFFEB 		bl	_tx_thread_sleep
 106:../cyfxbulksrcsink.c ****     }
 108              		.loc 1 106 0 discriminator 1
 109 0018 FCFFFFEA 		b	.L2
 110              		.cfi_endproc
 111              	.LFE0:
 113              		.align	2
 114              		.global	CyFxBulkSrcSinkApplnDebugInit
 116              	CyFxBulkSrcSinkApplnDebugInit:
 117              	.LFB1:
 107:../cyfxbulksrcsink.c **** }
 108:../cyfxbulksrcsink.c **** 
 109:../cyfxbulksrcsink.c **** /* This function initializes the debug module. The debug prints
 110:../cyfxbulksrcsink.c ****  * are routed to the UART and can be seen using a UART console
 111:../cyfxbulksrcsink.c ****  * running at 115200 baud rate. */
 112:../cyfxbulksrcsink.c **** void
 113:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnDebugInit (void)
 114:../cyfxbulksrcsink.c **** {
 118              		.loc 1 114 0
 119              		.cfi_startproc
 120              		@ args = 0, pretend = 0, frame = 64
 121              		@ frame_needed = 1, uses_anonymous_args = 0
 122 001c 00482DE9 		stmfd	sp!, {fp, lr}
 123              	.LCFI2:
 124              		.cfi_def_cfa_offset 8
 125 0020 04B08DE2 		add	fp, sp, #4
 126              		.cfi_offset 14, -4
 127              		.cfi_offset 11, -8
 128              	.LCFI3:
 129              		.cfi_def_cfa 11, 4
 130 0024 40D04DE2 		sub	sp, sp, #64
 115:../cyfxbulksrcsink.c ****     CyU3PGpioClock_t  gpioClock;
 116:../cyfxbulksrcsink.c ****     CyU3PUartConfig_t uartConfig;
 117:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 131              		.loc 1 117 0
 132 0028 0030A0E3 		mov	r3, #0
 133 002c 08300BE5 		str	r3, [fp, #-8]
 118:../cyfxbulksrcsink.c **** 
 119:../cyfxbulksrcsink.c ****     /* Initialize the GPIO block. If we are transitioning from the boot app, we can verify whether 
 120:../cyfxbulksrcsink.c ****        state is retained. */
 121:../cyfxbulksrcsink.c ****     gpioClock.fastClkDiv = 2;
 134              		.loc 1 121 0
 135 0030 0230A0E3 		mov	r3, #2
 136 0034 14304BE5 		strb	r3, [fp, #-20]
 122:../cyfxbulksrcsink.c ****     gpioClock.slowClkDiv = 32;
 137              		.loc 1 122 0
 138 0038 2030A0E3 		mov	r3, #32
 139 003c 13304BE5 		strb	r3, [fp, #-19]
 123:../cyfxbulksrcsink.c ****     gpioClock.simpleDiv  = CY_U3P_GPIO_SIMPLE_DIV_BY_16;
 140              		.loc 1 123 0
 141 0040 0230A0E3 		mov	r3, #2
 142 0044 0C304BE5 		strb	r3, [fp, #-12]
 124:../cyfxbulksrcsink.c ****     gpioClock.clkSrc     = CY_U3P_SYS_CLK_BY_2;
 143              		.loc 1 124 0
 144 0048 0230A0E3 		mov	r3, #2
 145 004c 0B304BE5 		strb	r3, [fp, #-11]
 125:../cyfxbulksrcsink.c ****     gpioClock.halfDiv    = 0;
 146              		.loc 1 125 0
 147 0050 0030A0E3 		mov	r3, #0
 148 0054 10300BE5 		str	r3, [fp, #-16]
 126:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PGpioInit (&gpioClock, NULL);
 149              		.loc 1 126 0
 150 0058 14304BE2 		sub	r3, fp, #20
 151 005c 0300A0E1 		mov	r0, r3
 152 0060 0010A0E3 		mov	r1, #0
 153 0064 FEFFFFEB 		bl	CyU3PGpioInit
 154 0068 08000BE5 		str	r0, [fp, #-8]
 127:../cyfxbulksrcsink.c **** 
 128:../cyfxbulksrcsink.c ****     /* When FX3 is restarting from standby mode, the GPIO block would already be ON and need not be
 129:../cyfxbulksrcsink.c ****        again. */
 130:../cyfxbulksrcsink.c ****     if ((apiRetStatus != 0) && (apiRetStatus != CY_U3P_ERROR_ALREADY_STARTED))
 155              		.loc 1 130 0
 156 006c 08301BE5 		ldr	r3, [fp, #-8]
 157 0070 000053E3 		cmp	r3, #0
 158 0074 0500000A 		beq	.L4
 159              		.loc 1 130 0 is_stmt 0 discriminator 1
 160 0078 08301BE5 		ldr	r3, [fp, #-8]
 161 007c 430053E3 		cmp	r3, #67
 162 0080 0200000A 		beq	.L4
 131:../cyfxbulksrcsink.c ****     {
 132:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 163              		.loc 1 132 0 is_stmt 1
 164 0084 08001BE5 		ldr	r0, [fp, #-8]
 165 0088 FEFFFFEB 		bl	CyFxAppErrorHandler
 166 008c 100000EA 		b	.L5
 167              	.L4:
 168              	.LBB2:
 133:../cyfxbulksrcsink.c ****     }
 134:../cyfxbulksrcsink.c ****     else
 135:../cyfxbulksrcsink.c ****     {
 136:../cyfxbulksrcsink.c ****         /* Set the test GPIO as an output and update the value to 1. */
 137:../cyfxbulksrcsink.c ****         CyU3PGpioSimpleConfig_t testConf = {CyTrue, CyTrue, CyTrue, CyFalse, CY_U3P_GPIO_NO_INTR};
 169              		.loc 1 137 0
 170 0090 20319FE5 		ldr	r3, .L10
 171 0094 40C04BE2 		sub	ip, fp, #64
 172 0098 03E0A0E1 		mov	lr, r3
 173 009c 0F00BEE8 		ldmia	lr!, {r0, r1, r2, r3}
 174 00a0 0F00ACE8 		stmia	ip!, {r0, r1, r2, r3}
 175 00a4 00309EE5 		ldr	r3, [lr, #0]
 176 00a8 00308CE5 		str	r3, [ip, #0]
 138:../cyfxbulksrcsink.c **** 
 139:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PGpioSetSimpleConfig (FX3_GPIO_TEST_OUT, &testConf);
 177              		.loc 1 139 0
 178 00ac 40304BE2 		sub	r3, fp, #64
 179 00b0 3200A0E3 		mov	r0, #50
 180 00b4 0310A0E1 		mov	r1, r3
 181 00b8 FEFFFFEB 		bl	CyU3PGpioSetSimpleConfig
 182 00bc 08000BE5 		str	r0, [fp, #-8]
 140:../cyfxbulksrcsink.c ****         if (apiRetStatus != 0)
 183              		.loc 1 140 0
 184 00c0 08301BE5 		ldr	r3, [fp, #-8]
 185 00c4 000053E3 		cmp	r3, #0
 186 00c8 0100000A 		beq	.L5
 141:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler (apiRetStatus);
 187              		.loc 1 141 0
 188 00cc 08001BE5 		ldr	r0, [fp, #-8]
 189 00d0 FEFFFFEB 		bl	CyFxAppErrorHandler
 190              	.L5:
 191              	.LBE2:
 142:../cyfxbulksrcsink.c ****     }
 143:../cyfxbulksrcsink.c **** 
 144:../cyfxbulksrcsink.c ****     /* Initialize the UART for printing debug messages */
 145:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUartInit();
 192              		.loc 1 145 0
 193 00d4 FEFFFFEB 		bl	CyU3PUartInit
 194 00d8 08000BE5 		str	r0, [fp, #-8]
 146:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 195              		.loc 1 146 0
 196 00dc 08301BE5 		ldr	r3, [fp, #-8]
 197 00e0 000053E3 		cmp	r3, #0
 198 00e4 0100000A 		beq	.L6
 147:../cyfxbulksrcsink.c ****     {
 148:../cyfxbulksrcsink.c ****         /* Error handling */
 149:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 199              		.loc 1 149 0
 200 00e8 08001BE5 		ldr	r0, [fp, #-8]
 201 00ec FEFFFFEB 		bl	CyFxAppErrorHandler
 202              	.L6:
 150:../cyfxbulksrcsink.c ****     }
 151:../cyfxbulksrcsink.c **** 
 152:../cyfxbulksrcsink.c ****     /* Set UART configuration */
 153:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&uartConfig, 0, sizeof (uartConfig));
 203              		.loc 1 153 0
 204 00f0 2C304BE2 		sub	r3, fp, #44
 205 00f4 0300A0E1 		mov	r0, r3
 206 00f8 0010A0E3 		mov	r1, #0
 207 00fc 1820A0E3 		mov	r2, #24
 208 0100 FEFFFFEB 		bl	CyU3PMemSet
 154:../cyfxbulksrcsink.c ****     uartConfig.baudRate = CY_U3P_UART_BAUDRATE_115200;
 209              		.loc 1 154 0
 210 0104 B0309FE5 		ldr	r3, .L10+4
 211 0108 1C300BE5 		str	r3, [fp, #-28]
 155:../cyfxbulksrcsink.c ****     uartConfig.stopBit = CY_U3P_UART_ONE_STOP_BIT;
 212              		.loc 1 155 0
 213 010c 0130A0E3 		mov	r3, #1
 214 0110 18304BE5 		strb	r3, [fp, #-24]
 156:../cyfxbulksrcsink.c ****     uartConfig.parity = CY_U3P_UART_NO_PARITY;
 215              		.loc 1 156 0
 216 0114 0030A0E3 		mov	r3, #0
 217 0118 17304BE5 		strb	r3, [fp, #-23]
 157:../cyfxbulksrcsink.c ****     uartConfig.txEnable = CyTrue;
 218              		.loc 1 157 0
 219 011c 0130A0E3 		mov	r3, #1
 220 0120 2C300BE5 		str	r3, [fp, #-44]
 158:../cyfxbulksrcsink.c ****     uartConfig.rxEnable = CyFalse;
 221              		.loc 1 158 0
 222 0124 0030A0E3 		mov	r3, #0
 223 0128 28300BE5 		str	r3, [fp, #-40]
 159:../cyfxbulksrcsink.c ****     uartConfig.flowCtrl = CyFalse;
 224              		.loc 1 159 0
 225 012c 0030A0E3 		mov	r3, #0
 226 0130 24300BE5 		str	r3, [fp, #-36]
 160:../cyfxbulksrcsink.c ****     uartConfig.isDma = CyTrue;
 227              		.loc 1 160 0
 228 0134 0130A0E3 		mov	r3, #1
 229 0138 20300BE5 		str	r3, [fp, #-32]
 161:../cyfxbulksrcsink.c **** 
 162:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUartSetConfig (&uartConfig, NULL);
 230              		.loc 1 162 0
 231 013c 2C304BE2 		sub	r3, fp, #44
 232 0140 0300A0E1 		mov	r0, r3
 233 0144 0010A0E3 		mov	r1, #0
 234 0148 FEFFFFEB 		bl	CyU3PUartSetConfig
 235 014c 08000BE5 		str	r0, [fp, #-8]
 163:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 236              		.loc 1 163 0
 237 0150 08301BE5 		ldr	r3, [fp, #-8]
 238 0154 000053E3 		cmp	r3, #0
 239 0158 0100000A 		beq	.L7
 164:../cyfxbulksrcsink.c ****     {
 165:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 240              		.loc 1 165 0
 241 015c 08001BE5 		ldr	r0, [fp, #-8]
 242 0160 FEFFFFEB 		bl	CyFxAppErrorHandler
 243              	.L7:
 166:../cyfxbulksrcsink.c ****     }
 167:../cyfxbulksrcsink.c **** 
 168:../cyfxbulksrcsink.c ****     /* Set the UART transfer to a really large value. */
 169:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUartTxSetBlockXfer (0xFFFFFFFF);
 244              		.loc 1 169 0
 245 0164 0000E0E3 		mvn	r0, #0
 246 0168 FEFFFFEB 		bl	CyU3PUartTxSetBlockXfer
 247 016c 08000BE5 		str	r0, [fp, #-8]
 170:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 248              		.loc 1 170 0
 249 0170 08301BE5 		ldr	r3, [fp, #-8]
 250 0174 000053E3 		cmp	r3, #0
 251 0178 0100000A 		beq	.L8
 171:../cyfxbulksrcsink.c ****     {
 172:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 252              		.loc 1 172 0
 253 017c 08001BE5 		ldr	r0, [fp, #-8]
 254 0180 FEFFFFEB 		bl	CyFxAppErrorHandler
 255              	.L8:
 173:../cyfxbulksrcsink.c ****     }
 174:../cyfxbulksrcsink.c **** 
 175:../cyfxbulksrcsink.c ****     /* Initialize the debug module. */
 176:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDebugInit (CY_U3P_LPP_SOCKET_UART_CONS, 8);
 256              		.loc 1 176 0
 257 0184 0300A0E3 		mov	r0, #3
 258 0188 0810A0E3 		mov	r1, #8
 259 018c FEFFFFEB 		bl	CyU3PDebugInit
 260 0190 08000BE5 		str	r0, [fp, #-8]
 177:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 261              		.loc 1 177 0
 262 0194 08301BE5 		ldr	r3, [fp, #-8]
 263 0198 000053E3 		cmp	r3, #0
 264 019c 0100000A 		beq	.L9
 178:../cyfxbulksrcsink.c ****     {
 179:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 265              		.loc 1 179 0
 266 01a0 08001BE5 		ldr	r0, [fp, #-8]
 267 01a4 FEFFFFEB 		bl	CyFxAppErrorHandler
 268              	.L9:
 180:../cyfxbulksrcsink.c ****     }
 181:../cyfxbulksrcsink.c **** 
 182:../cyfxbulksrcsink.c ****     CyU3PDebugPreamble(CyFalse);
 269              		.loc 1 182 0
 270 01a8 0000A0E3 		mov	r0, #0
 271 01ac FEFFFFEB 		bl	CyU3PDebugPreamble
 183:../cyfxbulksrcsink.c **** }
 272              		.loc 1 183 0
 273 01b0 04D04BE2 		sub	sp, fp, #4
 274 01b4 0088BDE8 		ldmfd	sp!, {fp, pc}
 275              	.L11:
 276              		.align	2
 277              	.L10:
 278 01b8 18040000 		.word	C.57.8416
 279 01bc 00C20100 		.word	115200
 280              		.cfi_endproc
 281              	.LFE1:
 283              		.section	.rodata
 284              		.align	2
 285              	.LC0:
 286 0000 43795533 		.ascii	"CyU3PDmaChannelDiscardBuffer failed, Error code = %"
 286      50446D61 
 286      4368616E 
 286      6E656C44 
 286      69736361 
 287 0033 640A00   		.ascii	"d\012\000"
 288 0036 0000     		.align	2
 289              	.LC1:
 290 0038 43795533 		.ascii	"CyU3PDmaChannelCommitBuffer failed, Error code = %d"
 290      50446D61 
 290      4368616E 
 290      6E656C43 
 290      6F6D6D69 
 291 006b 0A00     		.ascii	"\012\000"
 292 006d 000000   		.align	2
 293              	.LC2:
 294 0070 43795533 		.ascii	"CyU3PDmaChannelGetBuffer failed, Error code = %d\012"
 294      50446D61 
 294      4368616E 
 294      6E656C47 
 294      65744275 
 295 00a1 00       		.ascii	"\000"
 296              		.text
 297              		.align	2
 298              		.global	CyFxBulkSrcSinkDmaCallback
 300              	CyFxBulkSrcSinkDmaCallback:
 301              	.LFB2:
 184:../cyfxbulksrcsink.c **** 
 185:../cyfxbulksrcsink.c **** /* Callback funtion for the DMA event notification. */
 186:../cyfxbulksrcsink.c **** void
 187:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkDmaCallback (
 188:../cyfxbulksrcsink.c ****         CyU3PDmaChannel   *chHandle, /* Handle to the DMA channel. */
 189:../cyfxbulksrcsink.c ****         CyU3PDmaCbType_t  type,      /* Callback type.             */
 190:../cyfxbulksrcsink.c ****         CyU3PDmaCBInput_t *input)    /* Callback status.           */
 191:../cyfxbulksrcsink.c **** {
 302              		.loc 1 191 0
 303              		.cfi_startproc
 304              		@ args = 0, pretend = 0, frame = 32
 305              		@ frame_needed = 1, uses_anonymous_args = 0
 306 01c0 00482DE9 		stmfd	sp!, {fp, lr}
 307              	.LCFI4:
 308              		.cfi_def_cfa_offset 8
 309 01c4 04B08DE2 		add	fp, sp, #4
 310              		.cfi_offset 14, -4
 311              		.cfi_offset 11, -8
 312              	.LCFI5:
 313              		.cfi_def_cfa 11, 4
 314 01c8 20D04DE2 		sub	sp, sp, #32
 315 01cc 18000BE5 		str	r0, [fp, #-24]
 316 01d0 0130A0E1 		mov	r3, r1
 317 01d4 20200BE5 		str	r2, [fp, #-32]
 318 01d8 BA314BE1 		strh	r3, [fp, #-26]	@ movhi
 192:../cyfxbulksrcsink.c ****     CyU3PDmaBuffer_t buf_p;
 193:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 319              		.loc 1 193 0
 320 01dc 0030A0E3 		mov	r3, #0
 321 01e0 08300BE5 		str	r3, [fp, #-8]
 194:../cyfxbulksrcsink.c **** 
 195:../cyfxbulksrcsink.c ****     glDataTransStarted = CyTrue;
 322              		.loc 1 195 0
 323 01e4 E0309FE5 		ldr	r3, .L18
 324 01e8 0120A0E3 		mov	r2, #1
 325 01ec 002083E5 		str	r2, [r3, #0]
 196:../cyfxbulksrcsink.c **** 
 197:../cyfxbulksrcsink.c ****     if (type == CY_U3P_DMA_CB_PROD_EVENT)
 326              		.loc 1 197 0
 327 01f0 BA315BE1 		ldrh	r3, [fp, #-26]
 328 01f4 080053E3 		cmp	r3, #8
 329 01f8 0E00001A 		bne	.L13
 198:../cyfxbulksrcsink.c ****     {
 199:../cyfxbulksrcsink.c ****         /* This is a produce event notification to the CPU. This notification is 
 200:../cyfxbulksrcsink.c ****          * received upon reception of every buffer. We have to discard the buffer
 201:../cyfxbulksrcsink.c ****          * as soon as it is received to implement the data sink. */
 202:../cyfxbulksrcsink.c ****         status = CyU3PDmaChannelDiscardBuffer (chHandle);
 330              		.loc 1 202 0
 331 01fc 18001BE5 		ldr	r0, [fp, #-24]
 332 0200 FEFFFFEB 		bl	CyU3PDmaChannelDiscardBuffer
 333 0204 08000BE5 		str	r0, [fp, #-8]
 203:../cyfxbulksrcsink.c ****         if (status != CY_U3P_SUCCESS)
 334              		.loc 1 203 0
 335 0208 08301BE5 		ldr	r3, [fp, #-8]
 336 020c 000053E3 		cmp	r3, #0
 337 0210 0300000A 		beq	.L14
 204:../cyfxbulksrcsink.c ****         {
 205:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelDiscardBuffer failed, Error code = %d\n", status);
 338              		.loc 1 205 0
 339 0214 0400A0E3 		mov	r0, #4
 340 0218 B0109FE5 		ldr	r1, .L18+4
 341 021c 08201BE5 		ldr	r2, [fp, #-8]
 342 0220 FEFFFFEB 		bl	CyU3PDebugPrint
 343              	.L14:
 206:../cyfxbulksrcsink.c ****         }
 207:../cyfxbulksrcsink.c **** 
 208:../cyfxbulksrcsink.c ****         /* Increment the counter. */
 209:../cyfxbulksrcsink.c ****         glDMARxCount++;
 344              		.loc 1 209 0
 345 0224 A8309FE5 		ldr	r3, .L18+8
 346 0228 003093E5 		ldr	r3, [r3, #0]
 347 022c 012083E2 		add	r2, r3, #1
 348 0230 9C309FE5 		ldr	r3, .L18+8
 349 0234 002083E5 		str	r2, [r3, #0]
 350              	.L13:
 210:../cyfxbulksrcsink.c ****     }
 211:../cyfxbulksrcsink.c ****     if (type == CY_U3P_DMA_CB_CONS_EVENT)
 351              		.loc 1 211 0
 352 0238 BA315BE1 		ldrh	r3, [fp, #-26]
 353 023c 100053E3 		cmp	r3, #16
 354 0240 1F00001A 		bne	.L12
 212:../cyfxbulksrcsink.c ****     {
 213:../cyfxbulksrcsink.c ****         /* This is a consume event notification to the CPU. This notification is 
 214:../cyfxbulksrcsink.c ****          * received when a buffer is sent out from the device. We have to commit
 215:../cyfxbulksrcsink.c ****          * a new buffer as soon as a buffer is available to implement the data
 216:../cyfxbulksrcsink.c ****          * source. The data is preloaded into the buffer at that start. So just
 217:../cyfxbulksrcsink.c ****          * commit the buffer. */
 218:../cyfxbulksrcsink.c ****         status = CyU3PDmaChannelGetBuffer (chHandle, &buf_p, CYU3P_NO_WAIT);
 355              		.loc 1 218 0
 356 0244 14304BE2 		sub	r3, fp, #20
 357 0248 18001BE5 		ldr	r0, [fp, #-24]
 358 024c 0310A0E1 		mov	r1, r3
 359 0250 0020A0E3 		mov	r2, #0
 360 0254 FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 361 0258 08000BE5 		str	r0, [fp, #-8]
 219:../cyfxbulksrcsink.c ****         if (status == CY_U3P_SUCCESS)
 362              		.loc 1 219 0
 363 025c 08301BE5 		ldr	r3, [fp, #-8]
 364 0260 000053E3 		cmp	r3, #0
 365 0264 0D00001A 		bne	.L16
 220:../cyfxbulksrcsink.c ****         {
 221:../cyfxbulksrcsink.c ****             /* Commit the full buffer with default status. */
 222:../cyfxbulksrcsink.c ****             status = CyU3PDmaChannelCommitBuffer (chHandle, buf_p.size, 0);
 366              		.loc 1 222 0
 367 0268 BE305BE1 		ldrh	r3, [fp, #-14]
 368 026c 18001BE5 		ldr	r0, [fp, #-24]
 369 0270 0310A0E1 		mov	r1, r3
 370 0274 0020A0E3 		mov	r2, #0
 371 0278 FEFFFFEB 		bl	CyU3PDmaChannelCommitBuffer
 372 027c 08000BE5 		str	r0, [fp, #-8]
 223:../cyfxbulksrcsink.c ****             if (status != CY_U3P_SUCCESS)
 373              		.loc 1 223 0
 374 0280 08301BE5 		ldr	r3, [fp, #-8]
 375 0284 000053E3 		cmp	r3, #0
 376 0288 0800000A 		beq	.L17
 224:../cyfxbulksrcsink.c ****             {
 225:../cyfxbulksrcsink.c ****                 CyU3PDebugPrint (4, "CyU3PDmaChannelCommitBuffer failed, Error code = %d\n", status
 377              		.loc 1 225 0
 378 028c 0400A0E3 		mov	r0, #4
 379 0290 40109FE5 		ldr	r1, .L18+12
 380 0294 08201BE5 		ldr	r2, [fp, #-8]
 381 0298 FEFFFFEB 		bl	CyU3PDebugPrint
 382 029c 030000EA 		b	.L17
 383              	.L16:
 226:../cyfxbulksrcsink.c ****             }
 227:../cyfxbulksrcsink.c ****         }
 228:../cyfxbulksrcsink.c ****         else
 229:../cyfxbulksrcsink.c ****         {
 230:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelGetBuffer failed, Error code = %d\n", status);
 384              		.loc 1 230 0
 385 02a0 0400A0E3 		mov	r0, #4
 386 02a4 30109FE5 		ldr	r1, .L18+16
 387 02a8 08201BE5 		ldr	r2, [fp, #-8]
 388 02ac FEFFFFEB 		bl	CyU3PDebugPrint
 389              	.L17:
 231:../cyfxbulksrcsink.c ****         }
 232:../cyfxbulksrcsink.c **** 
 233:../cyfxbulksrcsink.c ****         /* Increment the counter. */
 234:../cyfxbulksrcsink.c ****         glDMATxCount++;
 390              		.loc 1 234 0
 391 02b0 28309FE5 		ldr	r3, .L18+20
 392 02b4 003093E5 		ldr	r3, [r3, #0]
 393 02b8 012083E2 		add	r2, r3, #1
 394 02bc 1C309FE5 		ldr	r3, .L18+20
 395 02c0 002083E5 		str	r2, [r3, #0]
 396              	.L12:
 235:../cyfxbulksrcsink.c ****     }
 236:../cyfxbulksrcsink.c **** }
 397              		.loc 1 236 0
 398 02c4 04D04BE2 		sub	sp, fp, #4
 399 02c8 0088BDE8 		ldmfd	sp!, {fp, pc}
 400              	.L19:
 401              		.align	2
 402              	.L18:
 403 02cc 00000000 		.word	glDataTransStarted
 404 02d0 00000000 		.word	.LC0
 405 02d4 00000000 		.word	glDMARxCount
 406 02d8 38000000 		.word	.LC1
 407 02dc 70000000 		.word	.LC2
 408 02e0 00000000 		.word	glDMATxCount
 409              		.cfi_endproc
 410              	.LFE2:
 412              		.section	.rodata
 413 00a2 0000     		.align	2
 414              	.LC3:
 415 00a4 4572726F 		.ascii	"Error! Invalid USB speed.\012\000"
 415      72212049 
 415      6E76616C 
 415      69642055 
 415      53422073 
 416 00bf 00       		.align	2
 417              	.LC4:
 418 00c0 43795533 		.ascii	"CyU3PSetEpConfig failed, Error code = %d\012\000"
 418      50536574 
 418      4570436F 
 418      6E666967 
 418      20666169 
 419 00ea 0000     		.align	2
 420              	.LC5:
 421 00ec 43795533 		.ascii	"CyU3PDmaChannelCreate failed, Error code = %d\012\000"
 421      50446D61 
 421      4368616E 
 421      6E656C43 
 421      72656174 
 422 011b 00       		.align	2
 423              	.LC6:
 424 011c 43795533 		.ascii	"CyU3PDmaChannelSetXfer failed, Error code = %d\012\000"
 424      50446D61 
 424      4368616E 
 424      6E656C53 
 424      65745866 
 425              		.text
 426              		.align	2
 427              		.global	CyFxBulkSrcSinkApplnStart
 429              	CyFxBulkSrcSinkApplnStart:
 430              	.LFB3:
 237:../cyfxbulksrcsink.c **** 
 238:../cyfxbulksrcsink.c **** /* This function starts the application. This is called
 239:../cyfxbulksrcsink.c ****  * when a SET_CONF event is received from the USB host. The endpoints
 240:../cyfxbulksrcsink.c ****  * are configured and the DMA pipe is setup in this function. */
 241:../cyfxbulksrcsink.c **** void
 242:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnStart (
 243:../cyfxbulksrcsink.c ****         void)
 244:../cyfxbulksrcsink.c **** {
 431              		.loc 1 244 0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 64
 434              		@ frame_needed = 1, uses_anonymous_args = 0
 435 02e4 00482DE9 		stmfd	sp!, {fp, lr}
 436              	.LCFI6:
 437              		.cfi_def_cfa_offset 8
 438 02e8 04B08DE2 		add	fp, sp, #4
 439              		.cfi_offset 14, -4
 440              		.cfi_offset 11, -8
 441              	.LCFI7:
 442              		.cfi_def_cfa 11, 4
 443 02ec 40D04DE2 		sub	sp, sp, #64
 245:../cyfxbulksrcsink.c ****     uint16_t size = 0, index = 0;
 444              		.loc 1 245 0
 445 02f0 0030A0E3 		mov	r3, #0
 446 02f4 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 447 02f8 0030A0E3 		mov	r3, #0
 448 02fc B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 246:../cyfxbulksrcsink.c ****     CyU3PEpConfig_t epCfg;
 247:../cyfxbulksrcsink.c ****     CyU3PDmaBuffer_t buf_p;
 248:../cyfxbulksrcsink.c ****     CyU3PDmaChannelConfig_t dmaCfg;
 249:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 449              		.loc 1 249 0
 450 0300 0030A0E3 		mov	r3, #0
 451 0304 0C300BE5 		str	r3, [fp, #-12]
 250:../cyfxbulksrcsink.c ****     CyU3PUSBSpeed_t usbSpeed = CyU3PUsbGetSpeed();
 452              		.loc 1 250 0
 453 0308 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 454 030c 0030A0E1 		mov	r3, r0
 455 0310 0D304BE5 		strb	r3, [fp, #-13]
 251:../cyfxbulksrcsink.c **** 
 252:../cyfxbulksrcsink.c ****     /* First identify the usb speed. Once that is identified,
 253:../cyfxbulksrcsink.c ****      * create a DMA channel and start the transfer on this. */
 254:../cyfxbulksrcsink.c **** 
 255:../cyfxbulksrcsink.c ****     /* Based on the Bus Speed configure the endpoint packet size */
 256:../cyfxbulksrcsink.c ****     switch (usbSpeed)
 456              		.loc 1 256 0
 457 0314 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 458 0318 020053E3 		cmp	r3, #2
 459 031c 0600000A 		beq	.L23
 460 0320 030053E3 		cmp	r3, #3
 461 0324 0700000A 		beq	.L24
 462 0328 010053E3 		cmp	r3, #1
 463 032c 0800001A 		bne	.L38
 464              	.L22:
 257:../cyfxbulksrcsink.c ****     {
 258:../cyfxbulksrcsink.c ****     case CY_U3P_FULL_SPEED:
 259:../cyfxbulksrcsink.c ****         size = 64;
 465              		.loc 1 259 0
 466 0330 4030A0E3 		mov	r3, #64
 467 0334 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 260:../cyfxbulksrcsink.c ****         break;
 468              		.loc 1 260 0
 469 0338 0B0000EA 		b	.L25
 470              	.L23:
 261:../cyfxbulksrcsink.c **** 
 262:../cyfxbulksrcsink.c ****     case CY_U3P_HIGH_SPEED:
 263:../cyfxbulksrcsink.c ****         size = 512;
 471              		.loc 1 263 0
 472 033c 023CA0E3 		mov	r3, #512
 473 0340 B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 264:../cyfxbulksrcsink.c ****         break;
 474              		.loc 1 264 0
 475 0344 080000EA 		b	.L25
 476              	.L24:
 265:../cyfxbulksrcsink.c **** 
 266:../cyfxbulksrcsink.c ****     case  CY_U3P_SUPER_SPEED:
 267:../cyfxbulksrcsink.c ****         size = 1024;
 477              		.loc 1 267 0
 478 0348 013BA0E3 		mov	r3, #1024
 479 034c B6304BE1 		strh	r3, [fp, #-6]	@ movhi
 268:../cyfxbulksrcsink.c ****         break;
 480              		.loc 1 268 0
 481 0350 050000EA 		b	.L25
 482              	.L38:
 269:../cyfxbulksrcsink.c **** 
 270:../cyfxbulksrcsink.c ****     default:
 271:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "Error! Invalid USB speed.\n");
 483              		.loc 1 271 0
 484 0354 0400A0E3 		mov	r0, #4
 485 0358 08139FE5 		ldr	r1, .L39
 486 035c FEFFFFEB 		bl	CyU3PDebugPrint
 272:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (CY_U3P_ERROR_FAILURE);
 487              		.loc 1 272 0
 488 0360 4A00A0E3 		mov	r0, #74
 489 0364 FEFFFFEB 		bl	CyFxAppErrorHandler
 273:../cyfxbulksrcsink.c ****         break;
 490              		.loc 1 273 0
 491 0368 0000A0E1 		mov	r0, r0	@ nop
 492              	.L25:
 274:../cyfxbulksrcsink.c ****     }
 275:../cyfxbulksrcsink.c **** 
 276:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&epCfg, 0, sizeof (epCfg));
 493              		.loc 1 276 0
 494 036c 1C304BE2 		sub	r3, fp, #28
 495 0370 0300A0E1 		mov	r0, r3
 496 0374 0010A0E3 		mov	r1, #0
 497 0378 0C20A0E3 		mov	r2, #12
 498 037c FEFFFFEB 		bl	CyU3PMemSet
 277:../cyfxbulksrcsink.c ****     epCfg.enable = CyTrue;
 499              		.loc 1 277 0
 500 0380 0130A0E3 		mov	r3, #1
 501 0384 1C300BE5 		str	r3, [fp, #-28]
 278:../cyfxbulksrcsink.c ****     epCfg.epType = CY_U3P_USB_EP_BULK;
 502              		.loc 1 278 0
 503 0388 0230A0E3 		mov	r3, #2
 504 038c 18304BE5 		strb	r3, [fp, #-24]
 279:../cyfxbulksrcsink.c ****     epCfg.burstLen = (usbSpeed == CY_U3P_SUPER_SPEED) ?
 505              		.loc 1 279 0
 506 0390 0D305BE5 		ldrb	r3, [fp, #-13]	@ zero_extendqisi2
 507 0394 030053E3 		cmp	r3, #3
 508 0398 0100001A 		bne	.L26
 509              		.loc 1 279 0 is_stmt 0 discriminator 1
 510 039c 1030A0E3 		mov	r3, #16
 511 03a0 000000EA 		b	.L27
 512              	.L26:
 513              		.loc 1 279 0 discriminator 2
 514 03a4 0130A0E3 		mov	r3, #1
 515              	.L27:
 516              		.loc 1 279 0 discriminator 3
 517 03a8 12304BE5 		strb	r3, [fp, #-18]
 280:../cyfxbulksrcsink.c ****         (CY_FX_EP_BURST_LENGTH) : 1;
 281:../cyfxbulksrcsink.c ****     epCfg.streams = 0;
 518              		.loc 1 281 0 is_stmt 1 discriminator 3
 519 03ac 0030A0E3 		mov	r3, #0
 520 03b0 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 282:../cyfxbulksrcsink.c ****     epCfg.pcktSize = size;
 521              		.loc 1 282 0 discriminator 3
 522 03b4 B6305BE1 		ldrh	r3, [fp, #-6]	@ movhi
 523 03b8 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 283:../cyfxbulksrcsink.c **** 
 284:../cyfxbulksrcsink.c ****     /* Producer endpoint configuration */
 285:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_PRODUCER, &epCfg);
 524              		.loc 1 285 0 discriminator 3
 525 03bc 1C304BE2 		sub	r3, fp, #28
 526 03c0 0100A0E3 		mov	r0, #1
 527 03c4 0310A0E1 		mov	r1, r3
 528 03c8 FEFFFFEB 		bl	CyU3PSetEpConfig
 529 03cc 0C000BE5 		str	r0, [fp, #-12]
 286:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 530              		.loc 1 286 0 discriminator 3
 531 03d0 0C301BE5 		ldr	r3, [fp, #-12]
 532 03d4 000053E3 		cmp	r3, #0
 533 03d8 0500000A 		beq	.L28
 287:../cyfxbulksrcsink.c ****     {
 288:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 534              		.loc 1 288 0
 535 03dc 0400A0E3 		mov	r0, #4
 536 03e0 84129FE5 		ldr	r1, .L39+4
 537 03e4 0C201BE5 		ldr	r2, [fp, #-12]
 538 03e8 FEFFFFEB 		bl	CyU3PDebugPrint
 289:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 539              		.loc 1 289 0
 540 03ec 0C001BE5 		ldr	r0, [fp, #-12]
 541 03f0 FEFFFFEB 		bl	CyFxAppErrorHandler
 542              	.L28:
 290:../cyfxbulksrcsink.c ****     }
 291:../cyfxbulksrcsink.c **** 
 292:../cyfxbulksrcsink.c ****     /* Consumer endpoint configuration */
 293:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_CONSUMER, &epCfg);
 543              		.loc 1 293 0
 544 03f4 1C304BE2 		sub	r3, fp, #28
 545 03f8 8100A0E3 		mov	r0, #129
 546 03fc 0310A0E1 		mov	r1, r3
 547 0400 FEFFFFEB 		bl	CyU3PSetEpConfig
 548 0404 0C000BE5 		str	r0, [fp, #-12]
 294:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 549              		.loc 1 294 0
 550 0408 0C301BE5 		ldr	r3, [fp, #-12]
 551 040c 000053E3 		cmp	r3, #0
 552 0410 0500000A 		beq	.L29
 295:../cyfxbulksrcsink.c ****     {
 296:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 553              		.loc 1 296 0
 554 0414 0400A0E3 		mov	r0, #4
 555 0418 4C129FE5 		ldr	r1, .L39+4
 556 041c 0C201BE5 		ldr	r2, [fp, #-12]
 557 0420 FEFFFFEB 		bl	CyU3PDebugPrint
 297:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 558              		.loc 1 297 0
 559 0424 0C001BE5 		ldr	r0, [fp, #-12]
 560 0428 FEFFFFEB 		bl	CyFxAppErrorHandler
 561              	.L29:
 298:../cyfxbulksrcsink.c ****     }
 299:../cyfxbulksrcsink.c **** 
 300:../cyfxbulksrcsink.c ****     /* Flush the endpoint memory */
 301:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_PRODUCER);
 562              		.loc 1 301 0
 563 042c 0100A0E3 		mov	r0, #1
 564 0430 FEFFFFEB 		bl	CyU3PUsbFlushEp
 302:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 565              		.loc 1 302 0
 566 0434 8100A0E3 		mov	r0, #129
 567 0438 FEFFFFEB 		bl	CyU3PUsbFlushEp
 303:../cyfxbulksrcsink.c **** 
 304:../cyfxbulksrcsink.c ****     /* Create a DMA MANUAL_IN channel for the producer socket. */
 305:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&dmaCfg, 0, sizeof (dmaCfg));
 568              		.loc 1 305 0
 569 043c 44304BE2 		sub	r3, fp, #68
 570 0440 0300A0E1 		mov	r0, r3
 571 0444 0010A0E3 		mov	r1, #0
 572 0448 1C20A0E3 		mov	r2, #28
 573 044c FEFFFFEB 		bl	CyU3PMemSet
 306:../cyfxbulksrcsink.c **** 
 307:../cyfxbulksrcsink.c ****     /* Set the DMA buffer size and count based on constants defined in the header file. */
 308:../cyfxbulksrcsink.c ****     dmaCfg.size  = CY_FX_BULKSRCSINK_DMA_BUF_SIZE;
 574              		.loc 1 308 0
 575 0450 0239A0E3 		mov	r3, #32768
 576 0454 B4344BE1 		strh	r3, [fp, #-68]	@ movhi
 309:../cyfxbulksrcsink.c ****     dmaCfg.count = CY_FX_BULKSRCSINK_DMA_BUF_COUNT;
 577              		.loc 1 309 0
 578 0458 0230A0E3 		mov	r3, #2
 579 045c B2344BE1 		strh	r3, [fp, #-66]	@ movhi
 310:../cyfxbulksrcsink.c ****     dmaCfg.prodSckId = CY_FX_EP_PRODUCER_SOCKET;
 580              		.loc 1 310 0
 581 0460 08329FE5 		ldr	r3, .L39+8
 582 0464 B0344BE1 		strh	r3, [fp, #-64]	@ movhi
 311:../cyfxbulksrcsink.c ****     dmaCfg.consSckId = CY_U3P_CPU_SOCKET_CONS;
 583              		.loc 1 311 0
 584 0468 3F3CA0E3 		mov	r3, #16128
 585 046c BE334BE1 		strh	r3, [fp, #-62]	@ movhi
 312:../cyfxbulksrcsink.c ****     dmaCfg.dmaMode = CY_U3P_DMA_MODE_BYTE;
 586              		.loc 1 312 0
 587 0470 0030A0E3 		mov	r3, #0
 588 0474 34304BE5 		strb	r3, [fp, #-52]
 313:../cyfxbulksrcsink.c ****     dmaCfg.notification = CY_U3P_DMA_CB_PROD_EVENT;
 589              		.loc 1 313 0
 590 0478 0830A0E3 		mov	r3, #8
 591 047c 30300BE5 		str	r3, [fp, #-48]
 314:../cyfxbulksrcsink.c ****     dmaCfg.cb = CyFxBulkSrcSinkDmaCallback;
 592              		.loc 1 314 0
 593 0480 EC319FE5 		ldr	r3, .L39+12
 594 0484 2C300BE5 		str	r3, [fp, #-44]
 315:../cyfxbulksrcsink.c ****     dmaCfg.prodHeader = 0;
 595              		.loc 1 315 0
 596 0488 0030A0E3 		mov	r3, #0
 597 048c BA334BE1 		strh	r3, [fp, #-58]	@ movhi
 316:../cyfxbulksrcsink.c ****     dmaCfg.prodFooter = 0;
 598              		.loc 1 316 0
 599 0490 0030A0E3 		mov	r3, #0
 600 0494 B8334BE1 		strh	r3, [fp, #-56]	@ movhi
 317:../cyfxbulksrcsink.c ****     dmaCfg.consHeader = 0;
 601              		.loc 1 317 0
 602 0498 0030A0E3 		mov	r3, #0
 603 049c B6334BE1 		strh	r3, [fp, #-54]	@ movhi
 318:../cyfxbulksrcsink.c ****     dmaCfg.prodAvailCount = 0;
 604              		.loc 1 318 0
 605 04a0 0030A0E3 		mov	r3, #0
 606 04a4 BC334BE1 		strh	r3, [fp, #-60]	@ movhi
 319:../cyfxbulksrcsink.c **** 
 320:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleBulkSink,
 607              		.loc 1 320 0
 608 04a8 44304BE2 		sub	r3, fp, #68
 609 04ac C4019FE5 		ldr	r0, .L39+16
 610 04b0 0310A0E3 		mov	r1, #3
 611 04b4 0320A0E1 		mov	r2, r3
 612 04b8 FEFFFFEB 		bl	CyU3PDmaChannelCreate
 613 04bc 0C000BE5 		str	r0, [fp, #-12]
 321:../cyfxbulksrcsink.c ****             CY_U3P_DMA_TYPE_MANUAL_IN, &dmaCfg);
 322:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 614              		.loc 1 322 0
 615 04c0 0C301BE5 		ldr	r3, [fp, #-12]
 616 04c4 000053E3 		cmp	r3, #0
 617 04c8 0500000A 		beq	.L30
 323:../cyfxbulksrcsink.c ****     {
 324:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelCreate failed, Error code = %d\n", apiRetStatus);
 618              		.loc 1 324 0
 619 04cc 0400A0E3 		mov	r0, #4
 620 04d0 A4119FE5 		ldr	r1, .L39+20
 621 04d4 0C201BE5 		ldr	r2, [fp, #-12]
 622 04d8 FEFFFFEB 		bl	CyU3PDebugPrint
 325:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 623              		.loc 1 325 0
 624 04dc 0C001BE5 		ldr	r0, [fp, #-12]
 625 04e0 FEFFFFEB 		bl	CyFxAppErrorHandler
 626              	.L30:
 326:../cyfxbulksrcsink.c ****     }
 327:../cyfxbulksrcsink.c **** 
 328:../cyfxbulksrcsink.c ****     /* Create a DMA MANUAL_OUT channel for the consumer socket. */
 329:../cyfxbulksrcsink.c ****     dmaCfg.notification = CY_U3P_DMA_CB_CONS_EVENT;
 627              		.loc 1 329 0
 628 04e4 1030A0E3 		mov	r3, #16
 629 04e8 30300BE5 		str	r3, [fp, #-48]
 330:../cyfxbulksrcsink.c ****     dmaCfg.prodSckId = CY_U3P_CPU_SOCKET_PROD;
 630              		.loc 1 330 0
 631 04ec 8C319FE5 		ldr	r3, .L39+24
 632 04f0 B0344BE1 		strh	r3, [fp, #-64]	@ movhi
 331:../cyfxbulksrcsink.c ****     dmaCfg.consSckId = CY_FX_EP_CONSUMER_SOCKET;
 633              		.loc 1 331 0
 634 04f4 88319FE5 		ldr	r3, .L39+28
 635 04f8 BE334BE1 		strh	r3, [fp, #-62]	@ movhi
 332:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelCreate (&glChHandleBulkSrc,
 636              		.loc 1 332 0
 637 04fc 44304BE2 		sub	r3, fp, #68
 638 0500 80019FE5 		ldr	r0, .L39+32
 639 0504 0410A0E3 		mov	r1, #4
 640 0508 0320A0E1 		mov	r2, r3
 641 050c FEFFFFEB 		bl	CyU3PDmaChannelCreate
 642 0510 0C000BE5 		str	r0, [fp, #-12]
 333:../cyfxbulksrcsink.c ****             CY_U3P_DMA_TYPE_MANUAL_OUT, &dmaCfg);
 334:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 643              		.loc 1 334 0
 644 0514 0C301BE5 		ldr	r3, [fp, #-12]
 645 0518 000053E3 		cmp	r3, #0
 646 051c 0500000A 		beq	.L31
 335:../cyfxbulksrcsink.c ****     {
 336:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelCreate failed, Error code = %d\n", apiRetStatus);
 647              		.loc 1 336 0
 648 0520 0400A0E3 		mov	r0, #4
 649 0524 50119FE5 		ldr	r1, .L39+20
 650 0528 0C201BE5 		ldr	r2, [fp, #-12]
 651 052c FEFFFFEB 		bl	CyU3PDebugPrint
 337:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 652              		.loc 1 337 0
 653 0530 0C001BE5 		ldr	r0, [fp, #-12]
 654 0534 FEFFFFEB 		bl	CyFxAppErrorHandler
 655              	.L31:
 338:../cyfxbulksrcsink.c ****     }
 339:../cyfxbulksrcsink.c **** 
 340:../cyfxbulksrcsink.c ****     /* Set DMA Channel transfer size */
 341:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glChHandleBulkSink, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 656              		.loc 1 341 0
 657 0538 38019FE5 		ldr	r0, .L39+16
 658 053c 0010A0E3 		mov	r1, #0
 659 0540 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 660 0544 0C000BE5 		str	r0, [fp, #-12]
 342:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 661              		.loc 1 342 0
 662 0548 0C301BE5 		ldr	r3, [fp, #-12]
 663 054c 000053E3 		cmp	r3, #0
 664 0550 0500000A 		beq	.L32
 343:../cyfxbulksrcsink.c ****     {
 344:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelSetXfer failed, Error code = %d\n", apiRetStatus);
 665              		.loc 1 344 0
 666 0554 0400A0E3 		mov	r0, #4
 667 0558 2C119FE5 		ldr	r1, .L39+36
 668 055c 0C201BE5 		ldr	r2, [fp, #-12]
 669 0560 FEFFFFEB 		bl	CyU3PDebugPrint
 345:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 670              		.loc 1 345 0
 671 0564 0C001BE5 		ldr	r0, [fp, #-12]
 672 0568 FEFFFFEB 		bl	CyFxAppErrorHandler
 673              	.L32:
 346:../cyfxbulksrcsink.c ****     }
 347:../cyfxbulksrcsink.c **** 
 348:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PDmaChannelSetXfer (&glChHandleBulkSrc, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 674              		.loc 1 348 0
 675 056c 14019FE5 		ldr	r0, .L39+32
 676 0570 0010A0E3 		mov	r1, #0
 677 0574 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 678 0578 0C000BE5 		str	r0, [fp, #-12]
 349:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 679              		.loc 1 349 0
 680 057c 0C301BE5 		ldr	r3, [fp, #-12]
 681 0580 000053E3 		cmp	r3, #0
 682 0584 0500000A 		beq	.L33
 350:../cyfxbulksrcsink.c ****     {
 351:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PDmaChannelSetXfer failed, Error code = %d\n", apiRetStatus);
 683              		.loc 1 351 0
 684 0588 0400A0E3 		mov	r0, #4
 685 058c F8109FE5 		ldr	r1, .L39+36
 686 0590 0C201BE5 		ldr	r2, [fp, #-12]
 687 0594 FEFFFFEB 		bl	CyU3PDebugPrint
 352:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 688              		.loc 1 352 0
 689 0598 0C001BE5 		ldr	r0, [fp, #-12]
 690 059c FEFFFFEB 		bl	CyFxAppErrorHandler
 691              	.L33:
 353:../cyfxbulksrcsink.c ****     }
 354:../cyfxbulksrcsink.c **** 
 355:../cyfxbulksrcsink.c ****     /* Now preload all buffers in the MANUAL_OUT pipe with the required data. */
 356:../cyfxbulksrcsink.c ****     for (index = 0; index < CY_FX_BULKSRCSINK_DMA_BUF_COUNT; index++)
 692              		.loc 1 356 0
 693 05a0 0030A0E3 		mov	r3, #0
 694 05a4 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 695 05a8 260000EA 		b	.L34
 696              	.L37:
 357:../cyfxbulksrcsink.c ****     {
 358:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PDmaChannelGetBuffer (&glChHandleBulkSrc, &buf_p, CYU3P_NO_WAIT);
 697              		.loc 1 358 0
 698 05ac 28304BE2 		sub	r3, fp, #40
 699 05b0 D0009FE5 		ldr	r0, .L39+32
 700 05b4 0310A0E1 		mov	r1, r3
 701 05b8 0020A0E3 		mov	r2, #0
 702 05bc FEFFFFEB 		bl	CyU3PDmaChannelGetBuffer
 703 05c0 0C000BE5 		str	r0, [fp, #-12]
 359:../cyfxbulksrcsink.c ****         if (apiRetStatus != CY_U3P_SUCCESS)
 704              		.loc 1 359 0
 705 05c4 0C301BE5 		ldr	r3, [fp, #-12]
 706 05c8 000053E3 		cmp	r3, #0
 707 05cc 0500000A 		beq	.L35
 360:../cyfxbulksrcsink.c ****         {
 361:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelGetBuffer failed, Error code = %d\n", apiRetStatus)
 708              		.loc 1 361 0
 709 05d0 0400A0E3 		mov	r0, #4
 710 05d4 B4109FE5 		ldr	r1, .L39+40
 711 05d8 0C201BE5 		ldr	r2, [fp, #-12]
 712 05dc FEFFFFEB 		bl	CyU3PDebugPrint
 362:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler(apiRetStatus);
 713              		.loc 1 362 0
 714 05e0 0C001BE5 		ldr	r0, [fp, #-12]
 715 05e4 FEFFFFEB 		bl	CyFxAppErrorHandler
 716              	.L35:
 363:../cyfxbulksrcsink.c ****         }
 364:../cyfxbulksrcsink.c ****         CyU3PMemSet (buf_p.buffer, CY_FX_BULKSRCSINK_PATTERN, buf_p.size);
 717              		.loc 1 364 0
 718 05e8 28201BE5 		ldr	r2, [fp, #-40]
 719 05ec B2325BE1 		ldrh	r3, [fp, #-34]
 720 05f0 0200A0E1 		mov	r0, r2
 721 05f4 AA10A0E3 		mov	r1, #170
 722 05f8 0320A0E1 		mov	r2, r3
 723 05fc FEFFFFEB 		bl	CyU3PMemSet
 365:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PDmaChannelCommitBuffer (&glChHandleBulkSrc, buf_p.size, 0);
 724              		.loc 1 365 0
 725 0600 B2325BE1 		ldrh	r3, [fp, #-34]
 726 0604 7C009FE5 		ldr	r0, .L39+32
 727 0608 0310A0E1 		mov	r1, r3
 728 060c 0020A0E3 		mov	r2, #0
 729 0610 FEFFFFEB 		bl	CyU3PDmaChannelCommitBuffer
 730 0614 0C000BE5 		str	r0, [fp, #-12]
 366:../cyfxbulksrcsink.c ****         if (apiRetStatus != CY_U3P_SUCCESS)
 731              		.loc 1 366 0
 732 0618 0C301BE5 		ldr	r3, [fp, #-12]
 733 061c 000053E3 		cmp	r3, #0
 734 0620 0500000A 		beq	.L36
 367:../cyfxbulksrcsink.c ****         {
 368:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "CyU3PDmaChannelCommitBuffer failed, Error code = %d\n", apiRetStat
 735              		.loc 1 368 0
 736 0624 0400A0E3 		mov	r0, #4
 737 0628 64109FE5 		ldr	r1, .L39+44
 738 062c 0C201BE5 		ldr	r2, [fp, #-12]
 739 0630 FEFFFFEB 		bl	CyU3PDebugPrint
 369:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler(apiRetStatus);
 740              		.loc 1 369 0
 741 0634 0C001BE5 		ldr	r0, [fp, #-12]
 742 0638 FEFFFFEB 		bl	CyFxAppErrorHandler
 743              	.L36:
 356:../cyfxbulksrcsink.c ****     for (index = 0; index < CY_FX_BULKSRCSINK_DMA_BUF_COUNT; index++)
 744              		.loc 1 356 0
 745 063c B8305BE1 		ldrh	r3, [fp, #-8]	@ movhi
 746 0640 013083E2 		add	r3, r3, #1
 747 0644 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 748              	.L34:
 356:../cyfxbulksrcsink.c ****     for (index = 0; index < CY_FX_BULKSRCSINK_DMA_BUF_COUNT; index++)
 749              		.loc 1 356 0 is_stmt 0 discriminator 1
 750 0648 B8305BE1 		ldrh	r3, [fp, #-8]
 751 064c 010053E3 		cmp	r3, #1
 752 0650 D5FFFF9A 		bls	.L37
 370:../cyfxbulksrcsink.c ****         }
 371:../cyfxbulksrcsink.c ****     }
 372:../cyfxbulksrcsink.c **** 
 373:../cyfxbulksrcsink.c ****     /* Update the flag so that the application thread is notified of this. */
 374:../cyfxbulksrcsink.c ****     glIsApplnActive = CyTrue;
 753              		.loc 1 374 0 is_stmt 1
 754 0654 3C309FE5 		ldr	r3, .L39+48
 755 0658 0120A0E3 		mov	r2, #1
 756 065c 002083E5 		str	r2, [r3, #0]
 375:../cyfxbulksrcsink.c **** }
 757              		.loc 1 375 0
 758 0660 04D04BE2 		sub	sp, fp, #4
 759 0664 0088BDE8 		ldmfd	sp!, {fp, pc}
 760              	.L40:
 761              		.align	2
 762              	.L39:
 763 0668 A4000000 		.word	.LC3
 764 066c C0000000 		.word	.LC4
 765 0670 01040000 		.word	1025
 766 0674 00000000 		.word	CyFxBulkSrcSinkDmaCallback
 767 0678 00000000 		.word	glChHandleBulkSink
 768 067c EC000000 		.word	.LC5
 769 0680 013F0000 		.word	16129
 770 0684 01030000 		.word	769
 771 0688 00000000 		.word	glChHandleBulkSrc
 772 068c 1C010000 		.word	.LC6
 773 0690 70000000 		.word	.LC2
 774 0694 38000000 		.word	.LC1
 775 0698 00000000 		.word	glIsApplnActive
 776              		.cfi_endproc
 777              	.LFE3:
 779              		.align	2
 780              		.global	CyFxBulkSrcSinkApplnStop
 782              	CyFxBulkSrcSinkApplnStop:
 783              	.LFB4:
 376:../cyfxbulksrcsink.c **** 
 377:../cyfxbulksrcsink.c **** /* This function stops the application. This shall be called whenever a RESET
 378:../cyfxbulksrcsink.c ****  * or DISCONNECT event is received from the USB host. The endpoints are
 379:../cyfxbulksrcsink.c ****  * disabled and the DMA pipe is destroyed by this function. */
 380:../cyfxbulksrcsink.c **** void
 381:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnStop (
 382:../cyfxbulksrcsink.c ****         void)
 383:../cyfxbulksrcsink.c **** {
 784              		.loc 1 383 0
 785              		.cfi_startproc
 786              		@ args = 0, pretend = 0, frame = 16
 787              		@ frame_needed = 1, uses_anonymous_args = 0
 788 069c 00482DE9 		stmfd	sp!, {fp, lr}
 789              	.LCFI8:
 790              		.cfi_def_cfa_offset 8
 791 06a0 04B08DE2 		add	fp, sp, #4
 792              		.cfi_offset 14, -4
 793              		.cfi_offset 11, -8
 794              	.LCFI9:
 795              		.cfi_def_cfa 11, 4
 796 06a4 10D04DE2 		sub	sp, sp, #16
 384:../cyfxbulksrcsink.c ****     CyU3PEpConfig_t epCfg;
 385:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 797              		.loc 1 385 0
 798 06a8 0030A0E3 		mov	r3, #0
 799 06ac 08300BE5 		str	r3, [fp, #-8]
 386:../cyfxbulksrcsink.c **** 
 387:../cyfxbulksrcsink.c ****     /* Update the flag so that the application thread is notified of this. */
 388:../cyfxbulksrcsink.c ****     glIsApplnActive = CyFalse;
 800              		.loc 1 388 0
 801 06b0 B8309FE5 		ldr	r3, .L44
 802 06b4 0020A0E3 		mov	r2, #0
 803 06b8 002083E5 		str	r2, [r3, #0]
 389:../cyfxbulksrcsink.c **** 
 390:../cyfxbulksrcsink.c ****     /* Destroy the channels */
 391:../cyfxbulksrcsink.c ****     CyU3PDmaChannelDestroy (&glChHandleBulkSink);
 804              		.loc 1 391 0
 805 06bc B0009FE5 		ldr	r0, .L44+4
 806 06c0 FEFFFFEB 		bl	CyU3PDmaChannelDestroy
 392:../cyfxbulksrcsink.c ****     CyU3PDmaChannelDestroy (&glChHandleBulkSrc);
 807              		.loc 1 392 0
 808 06c4 AC009FE5 		ldr	r0, .L44+8
 809 06c8 FEFFFFEB 		bl	CyU3PDmaChannelDestroy
 393:../cyfxbulksrcsink.c **** 
 394:../cyfxbulksrcsink.c ****     /* Flush the endpoint memory */
 395:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_PRODUCER);
 810              		.loc 1 395 0
 811 06cc 0100A0E3 		mov	r0, #1
 812 06d0 FEFFFFEB 		bl	CyU3PUsbFlushEp
 396:../cyfxbulksrcsink.c ****     CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 813              		.loc 1 396 0
 814 06d4 8100A0E3 		mov	r0, #129
 815 06d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
 397:../cyfxbulksrcsink.c **** 
 398:../cyfxbulksrcsink.c ****     /* Disable endpoints. */
 399:../cyfxbulksrcsink.c ****     CyU3PMemSet ((uint8_t *)&epCfg, 0, sizeof (epCfg));
 816              		.loc 1 399 0
 817 06dc 14304BE2 		sub	r3, fp, #20
 818 06e0 0300A0E1 		mov	r0, r3
 819 06e4 0010A0E3 		mov	r1, #0
 820 06e8 0C20A0E3 		mov	r2, #12
 821 06ec FEFFFFEB 		bl	CyU3PMemSet
 400:../cyfxbulksrcsink.c ****     epCfg.enable = CyFalse;
 822              		.loc 1 400 0
 823 06f0 0030A0E3 		mov	r3, #0
 824 06f4 14300BE5 		str	r3, [fp, #-20]
 401:../cyfxbulksrcsink.c **** 
 402:../cyfxbulksrcsink.c ****     /* Producer endpoint configuration. */
 403:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_PRODUCER, &epCfg);
 825              		.loc 1 403 0
 826 06f8 14304BE2 		sub	r3, fp, #20
 827 06fc 0100A0E3 		mov	r0, #1
 828 0700 0310A0E1 		mov	r1, r3
 829 0704 FEFFFFEB 		bl	CyU3PSetEpConfig
 830 0708 08000BE5 		str	r0, [fp, #-8]
 404:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 831              		.loc 1 404 0
 832 070c 08301BE5 		ldr	r3, [fp, #-8]
 833 0710 000053E3 		cmp	r3, #0
 834 0714 0500000A 		beq	.L42
 405:../cyfxbulksrcsink.c ****     {
 406:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 835              		.loc 1 406 0
 836 0718 0400A0E3 		mov	r0, #4
 837 071c 58109FE5 		ldr	r1, .L44+12
 838 0720 08201BE5 		ldr	r2, [fp, #-8]
 839 0724 FEFFFFEB 		bl	CyU3PDebugPrint
 407:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 840              		.loc 1 407 0
 841 0728 08001BE5 		ldr	r0, [fp, #-8]
 842 072c FEFFFFEB 		bl	CyFxAppErrorHandler
 843              	.L42:
 408:../cyfxbulksrcsink.c ****     }
 409:../cyfxbulksrcsink.c **** 
 410:../cyfxbulksrcsink.c ****     /* Consumer endpoint configuration. */
 411:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PSetEpConfig(CY_FX_EP_CONSUMER, &epCfg);
 844              		.loc 1 411 0
 845 0730 14304BE2 		sub	r3, fp, #20
 846 0734 8100A0E3 		mov	r0, #129
 847 0738 0310A0E1 		mov	r1, r3
 848 073c FEFFFFEB 		bl	CyU3PSetEpConfig
 849 0740 08000BE5 		str	r0, [fp, #-8]
 412:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 850              		.loc 1 412 0
 851 0744 08301BE5 		ldr	r3, [fp, #-8]
 852 0748 000053E3 		cmp	r3, #0
 853 074c 0500000A 		beq	.L41
 413:../cyfxbulksrcsink.c ****     {
 414:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PSetEpConfig failed, Error code = %d\n", apiRetStatus);
 854              		.loc 1 414 0
 855 0750 0400A0E3 		mov	r0, #4
 856 0754 20109FE5 		ldr	r1, .L44+12
 857 0758 08201BE5 		ldr	r2, [fp, #-8]
 858 075c FEFFFFEB 		bl	CyU3PDebugPrint
 415:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler (apiRetStatus);
 859              		.loc 1 415 0
 860 0760 08001BE5 		ldr	r0, [fp, #-8]
 861 0764 FEFFFFEB 		bl	CyFxAppErrorHandler
 862              	.L41:
 416:../cyfxbulksrcsink.c ****     }
 417:../cyfxbulksrcsink.c **** }
 863              		.loc 1 417 0
 864 0768 04D04BE2 		sub	sp, fp, #4
 865 076c 0088BDE8 		ldmfd	sp!, {fp, pc}
 866              	.L45:
 867              		.align	2
 868              	.L44:
 869 0770 00000000 		.word	glIsApplnActive
 870 0774 00000000 		.word	glChHandleBulkSink
 871 0778 00000000 		.word	glChHandleBulkSrc
 872 077c C0000000 		.word	.LC4
 873              		.cfi_endproc
 874              	.LFE4:
 876              		.align	2
 877              		.global	CyFxBulkSrcSinkApplnUSBSetupCB
 879              	CyFxBulkSrcSinkApplnUSBSetupCB:
 880              	.LFB5:
 418:../cyfxbulksrcsink.c **** 
 419:../cyfxbulksrcsink.c **** /* Callback to handle the USB setup requests. */
 420:../cyfxbulksrcsink.c **** CyBool_t
 421:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnUSBSetupCB (
 422:../cyfxbulksrcsink.c ****         uint32_t setupdat0, /* SETUP Data 0 */
 423:../cyfxbulksrcsink.c ****         uint32_t setupdat1  /* SETUP Data 1 */
 424:../cyfxbulksrcsink.c ****     )
 425:../cyfxbulksrcsink.c **** {
 881              		.loc 1 425 0
 882              		.cfi_startproc
 883              		@ args = 0, pretend = 0, frame = 24
 884              		@ frame_needed = 1, uses_anonymous_args = 0
 885 0780 00482DE9 		stmfd	sp!, {fp, lr}
 886              	.LCFI10:
 887              		.cfi_def_cfa_offset 8
 888 0784 04B08DE2 		add	fp, sp, #4
 889              		.cfi_offset 14, -4
 890              		.cfi_offset 11, -8
 891              	.LCFI11:
 892              		.cfi_def_cfa 11, 4
 893 0788 18D04DE2 		sub	sp, sp, #24
 894 078c 18000BE5 		str	r0, [fp, #-24]
 895 0790 1C100BE5 		str	r1, [fp, #-28]
 426:../cyfxbulksrcsink.c ****     /* Fast enumeration is used. Only requests addressed to the interface, class,
 427:../cyfxbulksrcsink.c ****      * vendor and unknown control requests are received by this function.
 428:../cyfxbulksrcsink.c ****      * This application does not support any class or vendor requests. */
 429:../cyfxbulksrcsink.c **** 
 430:../cyfxbulksrcsink.c ****     uint8_t  bRequest, bReqType;
 431:../cyfxbulksrcsink.c ****     uint8_t  bType, bTarget;
 432:../cyfxbulksrcsink.c ****     uint16_t wValue, wIndex, wLength;
 433:../cyfxbulksrcsink.c ****     CyBool_t isHandled = CyFalse;
 896              		.loc 1 433 0
 897 0794 0030A0E3 		mov	r3, #0
 898 0798 08300BE5 		str	r3, [fp, #-8]
 434:../cyfxbulksrcsink.c **** 
 435:../cyfxbulksrcsink.c ****     /* Decode the fields from the setup request. */
 436:../cyfxbulksrcsink.c ****     bReqType = (setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 899              		.loc 1 436 0
 900 079c 18301BE5 		ldr	r3, [fp, #-24]
 901 07a0 09304BE5 		strb	r3, [fp, #-9]
 437:../cyfxbulksrcsink.c ****     bType    = (bReqType & CY_U3P_USB_TYPE_MASK);
 902              		.loc 1 437 0
 903 07a4 09305BE5 		ldrb	r3, [fp, #-9]
 904 07a8 603003E2 		and	r3, r3, #96
 905 07ac 0A304BE5 		strb	r3, [fp, #-10]
 438:../cyfxbulksrcsink.c ****     bTarget  = (bReqType & CY_U3P_USB_TARGET_MASK);
 906              		.loc 1 438 0
 907 07b0 09305BE5 		ldrb	r3, [fp, #-9]
 908 07b4 033003E2 		and	r3, r3, #3
 909 07b8 0B304BE5 		strb	r3, [fp, #-11]
 439:../cyfxbulksrcsink.c ****     bRequest = ((setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 910              		.loc 1 439 0
 911 07bc 18301BE5 		ldr	r3, [fp, #-24]
 912 07c0 FF3C03E2 		and	r3, r3, #65280
 913 07c4 2334A0E1 		mov	r3, r3, lsr #8
 914 07c8 0C304BE5 		strb	r3, [fp, #-12]
 440:../cyfxbulksrcsink.c ****     wValue   = ((setupdat0 & CY_U3P_USB_VALUE_MASK)   >> CY_U3P_USB_VALUE_POS);
 915              		.loc 1 440 0
 916 07cc 18301BE5 		ldr	r3, [fp, #-24]
 917 07d0 2338A0E1 		mov	r3, r3, lsr #16
 918 07d4 BE304BE1 		strh	r3, [fp, #-14]	@ movhi
 441:../cyfxbulksrcsink.c ****     wIndex   = ((setupdat1 & CY_U3P_USB_INDEX_MASK)   >> CY_U3P_USB_INDEX_POS);
 919              		.loc 1 441 0
 920 07d8 1C301BE5 		ldr	r3, [fp, #-28]
 921 07dc B0314BE1 		strh	r3, [fp, #-16]	@ movhi
 442:../cyfxbulksrcsink.c ****     wLength  = ((setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 922              		.loc 1 442 0
 923 07e0 1C301BE5 		ldr	r3, [fp, #-28]
 924 07e4 2338A0E1 		mov	r3, r3, lsr #16
 925 07e8 B2314BE1 		strh	r3, [fp, #-18]	@ movhi
 443:../cyfxbulksrcsink.c **** 
 444:../cyfxbulksrcsink.c ****     if (bType == CY_U3P_USB_STANDARD_RQT)
 926              		.loc 1 444 0
 927 07ec 0A305BE5 		ldrb	r3, [fp, #-10]	@ zero_extendqisi2
 928 07f0 000053E3 		cmp	r3, #0
 929 07f4 5B00001A 		bne	.L47
 445:../cyfxbulksrcsink.c ****     {
 446:../cyfxbulksrcsink.c ****         /* Handle SET_FEATURE(FUNCTION_SUSPEND) and CLEAR_FEATURE(FUNCTION_SUSPEND)
 447:../cyfxbulksrcsink.c ****          * requests here. It should be allowed to pass if the device is in configured
 448:../cyfxbulksrcsink.c ****          * state and failed otherwise. */
 449:../cyfxbulksrcsink.c ****         if ((bTarget == CY_U3P_USB_TARGET_INTF) && ((bRequest == CY_U3P_USB_SC_SET_FEATURE)
 930              		.loc 1 449 0
 931 07f8 0B305BE5 		ldrb	r3, [fp, #-11]	@ zero_extendqisi2
 932 07fc 010053E3 		cmp	r3, #1
 933 0800 2100001A 		bne	.L48
 934              		.loc 1 449 0 is_stmt 0 discriminator 1
 935 0804 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 936 0808 030053E3 		cmp	r3, #3
 937 080c 0200000A 		beq	.L49
 450:../cyfxbulksrcsink.c ****                     || (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)) && (wValue == 0))
 938              		.loc 1 450 0 is_stmt 1
 939 0810 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 940 0814 010053E3 		cmp	r3, #1
 941 0818 1B00001A 		bne	.L48
 942              	.L49:
 943              		.loc 1 450 0 is_stmt 0 discriminator 1
 944 081c BE305BE1 		ldrh	r3, [fp, #-14]
 945 0820 000053E3 		cmp	r3, #0
 946 0824 1800001A 		bne	.L48
 451:../cyfxbulksrcsink.c ****         {
 452:../cyfxbulksrcsink.c ****             if (glIsApplnActive)
 947              		.loc 1 452 0 is_stmt 1
 948 0828 90319FE5 		ldr	r3, .L55
 949 082c 003093E5 		ldr	r3, [r3, #0]
 950 0830 000053E3 		cmp	r3, #0
 951 0834 0E00000A 		beq	.L50
 453:../cyfxbulksrcsink.c ****             {
 454:../cyfxbulksrcsink.c ****                 CyU3PUsbAckSetup ();
 952              		.loc 1 454 0
 953 0838 FEFFFFEB 		bl	CyU3PUsbAckSetup
 455:../cyfxbulksrcsink.c **** 
 456:../cyfxbulksrcsink.c ****                 /* As we have only one interface, the link can be pushed into U2 state as soon as
 457:../cyfxbulksrcsink.c ****                    this interface is suspended.
 458:../cyfxbulksrcsink.c ****                  */
 459:../cyfxbulksrcsink.c ****                 if (bRequest == CY_U3P_USB_SC_SET_FEATURE)
 954              		.loc 1 459 0
 955 083c 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 956 0840 030053E3 		cmp	r3, #3
 957 0844 0600001A 		bne	.L51
 460:../cyfxbulksrcsink.c ****                 {
 461:../cyfxbulksrcsink.c ****                     glDataTransStarted = CyFalse;
 958              		.loc 1 461 0
 959 0848 74319FE5 		ldr	r3, .L55+4
 960 084c 0020A0E3 		mov	r2, #0
 961 0850 002083E5 		str	r2, [r3, #0]
 462:../cyfxbulksrcsink.c ****                     glForceLinkU2      = CyTrue;
 962              		.loc 1 462 0
 963 0854 6C319FE5 		ldr	r3, .L55+8
 964 0858 0120A0E3 		mov	r2, #1
 965 085c 002083E5 		str	r2, [r3, #0]
 966 0860 070000EA 		b	.L52
 967              	.L51:
 463:../cyfxbulksrcsink.c ****                 }
 464:../cyfxbulksrcsink.c ****                 else
 465:../cyfxbulksrcsink.c ****                 {
 466:../cyfxbulksrcsink.c ****                     glForceLinkU2 = CyFalse;
 968              		.loc 1 466 0
 969 0864 5C319FE5 		ldr	r3, .L55+8
 970 0868 0020A0E3 		mov	r2, #0
 971 086c 002083E5 		str	r2, [r3, #0]
 972 0870 030000EA 		b	.L52
 973              	.L50:
 467:../cyfxbulksrcsink.c ****                 }
 468:../cyfxbulksrcsink.c ****             }
 469:../cyfxbulksrcsink.c ****             else
 470:../cyfxbulksrcsink.c ****                 CyU3PUsbStall (0, CyTrue, CyFalse);
 974              		.loc 1 470 0
 975 0874 0000A0E3 		mov	r0, #0
 976 0878 0110A0E3 		mov	r1, #1
 977 087c 0020A0E3 		mov	r2, #0
 978 0880 FEFFFFEB 		bl	CyU3PUsbStall
 979              	.L52:
 471:../cyfxbulksrcsink.c **** 
 472:../cyfxbulksrcsink.c ****             isHandled = CyTrue;
 980              		.loc 1 472 0
 981 0884 0130A0E3 		mov	r3, #1
 982 0888 08300BE5 		str	r3, [fp, #-8]
 983              	.L48:
 473:../cyfxbulksrcsink.c ****         }
 474:../cyfxbulksrcsink.c **** 
 475:../cyfxbulksrcsink.c ****         /* CLEAR_FEATURE request for endpoint is always passed to the setup callback
 476:../cyfxbulksrcsink.c ****          * regardless of the enumeration model used. When a clear feature is received,
 477:../cyfxbulksrcsink.c ****          * the previous transfer has to be flushed and cleaned up. This is done at the
 478:../cyfxbulksrcsink.c ****          * protocol level. Since this is just a loopback operation, there is no higher
 479:../cyfxbulksrcsink.c ****          * level protocol. So flush the EP memory and reset the DMA channel associated
 480:../cyfxbulksrcsink.c ****          * with it. If there are more than one EP associated with the channel reset both
 481:../cyfxbulksrcsink.c ****          * the EPs. The endpoint stall and toggle / sequence number is also expected to be
 482:../cyfxbulksrcsink.c ****          * reset. Return CyFalse to make the library clear the stall and reset the endpoint
 483:../cyfxbulksrcsink.c ****          * toggle. Or invoke the CyU3PUsbStall (ep, CyFalse, CyTrue) and return CyTrue.
 484:../cyfxbulksrcsink.c ****          * Here we are clearing the stall. */
 485:../cyfxbulksrcsink.c ****         if ((bTarget == CY_U3P_USB_TARGET_ENDPT) && (bRequest == CY_U3P_USB_SC_CLEAR_FEATURE)
 984              		.loc 1 485 0
 985 088c 0B305BE5 		ldrb	r3, [fp, #-11]	@ zero_extendqisi2
 986 0890 020053E3 		cmp	r3, #2
 987 0894 3300001A 		bne	.L47
 988              		.loc 1 485 0 is_stmt 0 discriminator 1
 989 0898 0C305BE5 		ldrb	r3, [fp, #-12]	@ zero_extendqisi2
 990 089c 010053E3 		cmp	r3, #1
 991 08a0 3000001A 		bne	.L47
 486:../cyfxbulksrcsink.c ****                 && (wValue == CY_U3P_USBX_FS_EP_HALT))
 992              		.loc 1 486 0 is_stmt 1
 993 08a4 BE305BE1 		ldrh	r3, [fp, #-14]
 994 08a8 000053E3 		cmp	r3, #0
 995 08ac 2D00001A 		bne	.L47
 487:../cyfxbulksrcsink.c ****         {
 488:../cyfxbulksrcsink.c ****             if (glIsApplnActive)
 996              		.loc 1 488 0
 997 08b0 08319FE5 		ldr	r3, .L55
 998 08b4 003093E5 		ldr	r3, [r3, #0]
 999 08b8 000053E3 		cmp	r3, #0
 1000 08bc 2900000A 		beq	.L47
 489:../cyfxbulksrcsink.c ****             {
 490:../cyfxbulksrcsink.c ****                 if (wIndex == CY_FX_EP_PRODUCER)
 1001              		.loc 1 490 0
 1002 08c0 B0315BE1 		ldrh	r3, [fp, #-16]
 1003 08c4 010053E3 		cmp	r3, #1
 1004 08c8 1100001A 		bne	.L53
 491:../cyfxbulksrcsink.c ****                 {
 492:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelReset (&glChHandleBulkSink);
 1005              		.loc 1 492 0
 1006 08cc F8009FE5 		ldr	r0, .L55+12
 1007 08d0 FEFFFFEB 		bl	CyU3PDmaChannelReset
 493:../cyfxbulksrcsink.c ****                     CyU3PUsbFlushEp(CY_FX_EP_PRODUCER);
 1008              		.loc 1 493 0
 1009 08d4 0100A0E3 		mov	r0, #1
 1010 08d8 FEFFFFEB 		bl	CyU3PUsbFlushEp
 494:../cyfxbulksrcsink.c ****                     CyU3PUsbResetEp (CY_FX_EP_PRODUCER);
 1011              		.loc 1 494 0
 1012 08dc 0100A0E3 		mov	r0, #1
 1013 08e0 FEFFFFEB 		bl	CyU3PUsbResetEp
 495:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelSetXfer (&glChHandleBulkSink, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 1014              		.loc 1 495 0
 1015 08e4 E0009FE5 		ldr	r0, .L55+12
 1016 08e8 0010A0E3 		mov	r1, #0
 1017 08ec FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 496:../cyfxbulksrcsink.c ****                     CyU3PUsbStall (wIndex, CyFalse, CyTrue);
 1018              		.loc 1 496 0
 1019 08f0 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1020 08f4 FF3003E2 		and	r3, r3, #255
 1021 08f8 0300A0E1 		mov	r0, r3
 1022 08fc 0010A0E3 		mov	r1, #0
 1023 0900 0120A0E3 		mov	r2, #1
 1024 0904 FEFFFFEB 		bl	CyU3PUsbStall
 497:../cyfxbulksrcsink.c ****                     isHandled = CyTrue;
 1025              		.loc 1 497 0
 1026 0908 0130A0E3 		mov	r3, #1
 1027 090c 08300BE5 		str	r3, [fp, #-8]
 498:../cyfxbulksrcsink.c ****                     CyU3PUsbAckSetup ();
 1028              		.loc 1 498 0
 1029 0910 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1030              	.L53:
 499:../cyfxbulksrcsink.c ****                 }
 500:../cyfxbulksrcsink.c **** 
 501:../cyfxbulksrcsink.c ****                 if (wIndex == CY_FX_EP_CONSUMER)
 1031              		.loc 1 501 0
 1032 0914 B0315BE1 		ldrh	r3, [fp, #-16]
 1033 0918 810053E3 		cmp	r3, #129
 1034 091c 1100001A 		bne	.L47
 502:../cyfxbulksrcsink.c ****                 {
 503:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelReset (&glChHandleBulkSrc);
 1035              		.loc 1 503 0
 1036 0920 A8009FE5 		ldr	r0, .L55+16
 1037 0924 FEFFFFEB 		bl	CyU3PDmaChannelReset
 504:../cyfxbulksrcsink.c ****                     CyU3PUsbFlushEp(CY_FX_EP_CONSUMER);
 1038              		.loc 1 504 0
 1039 0928 8100A0E3 		mov	r0, #129
 1040 092c FEFFFFEB 		bl	CyU3PUsbFlushEp
 505:../cyfxbulksrcsink.c ****                     CyU3PUsbResetEp (CY_FX_EP_CONSUMER);
 1041              		.loc 1 505 0
 1042 0930 8100A0E3 		mov	r0, #129
 1043 0934 FEFFFFEB 		bl	CyU3PUsbResetEp
 506:../cyfxbulksrcsink.c ****                     CyU3PDmaChannelSetXfer (&glChHandleBulkSrc, CY_FX_BULKSRCSINK_DMA_TX_SIZE);
 1044              		.loc 1 506 0
 1045 0938 90009FE5 		ldr	r0, .L55+16
 1046 093c 0010A0E3 		mov	r1, #0
 1047 0940 FEFFFFEB 		bl	CyU3PDmaChannelSetXfer
 507:../cyfxbulksrcsink.c ****                     CyU3PUsbStall (wIndex, CyFalse, CyTrue);
 1048              		.loc 1 507 0
 1049 0944 B0315BE1 		ldrh	r3, [fp, #-16]	@ movhi
 1050 0948 FF3003E2 		and	r3, r3, #255
 1051 094c 0300A0E1 		mov	r0, r3
 1052 0950 0010A0E3 		mov	r1, #0
 1053 0954 0120A0E3 		mov	r2, #1
 1054 0958 FEFFFFEB 		bl	CyU3PUsbStall
 508:../cyfxbulksrcsink.c ****                     isHandled = CyTrue;
 1055              		.loc 1 508 0
 1056 095c 0130A0E3 		mov	r3, #1
 1057 0960 08300BE5 		str	r3, [fp, #-8]
 509:../cyfxbulksrcsink.c ****                     CyU3PUsbAckSetup ();
 1058              		.loc 1 509 0
 1059 0964 FEFFFFEB 		bl	CyU3PUsbAckSetup
 1060              	.L47:
 510:../cyfxbulksrcsink.c ****                 }
 511:../cyfxbulksrcsink.c ****             }
 512:../cyfxbulksrcsink.c ****         }
 513:../cyfxbulksrcsink.c ****     }
 514:../cyfxbulksrcsink.c **** 
 515:../cyfxbulksrcsink.c ****     if ((bType == CY_U3P_USB_VENDOR_RQT) && (bTarget == CY_U3P_USB_TARGET_DEVICE))
 1061              		.loc 1 515 0
 1062 0968 0A305BE5 		ldrb	r3, [fp, #-10]	@ zero_extendqisi2
 1063 096c 400053E3 		cmp	r3, #64
 1064 0970 0E00001A 		bne	.L54
 1065              		.loc 1 515 0 is_stmt 0 discriminator 1
 1066 0974 0B305BE5 		ldrb	r3, [fp, #-11]	@ zero_extendqisi2
 1067 0978 000053E3 		cmp	r3, #0
 1068 097c 0B00001A 		bne	.L54
 516:../cyfxbulksrcsink.c ****     {
 517:../cyfxbulksrcsink.c ****         /* We set an event here and let the application thread below handle these requests.
 518:../cyfxbulksrcsink.c ****          * isHandled needs to be set to True, so that the driver does not stall EP0. */
 519:../cyfxbulksrcsink.c ****         isHandled = CyTrue;
 1069              		.loc 1 519 0 is_stmt 1
 1070 0980 0130A0E3 		mov	r3, #1
 1071 0984 08300BE5 		str	r3, [fp, #-8]
 520:../cyfxbulksrcsink.c ****         gl_setupdat0 = setupdat0;
 1072              		.loc 1 520 0
 1073 0988 44309FE5 		ldr	r3, .L55+20
 1074 098c 18201BE5 		ldr	r2, [fp, #-24]
 1075 0990 002083E5 		str	r2, [r3, #0]
 521:../cyfxbulksrcsink.c ****         gl_setupdat1 = setupdat1;
 1076              		.loc 1 521 0
 1077 0994 3C309FE5 		ldr	r3, .L55+24
 1078 0998 1C201BE5 		ldr	r2, [fp, #-28]
 1079 099c 002083E5 		str	r2, [r3, #0]
 522:../cyfxbulksrcsink.c ****         CyU3PEventSet (&glBulkLpEvent, CYFX_USB_CTRL_TASK, CYU3P_EVENT_OR);
 1080              		.loc 1 522 0
 1081 09a0 34009FE5 		ldr	r0, .L55+28
 1082 09a4 0110A0E3 		mov	r1, #1
 1083 09a8 0020A0E3 		mov	r2, #0
 1084 09ac FEFFFFEB 		bl	_txe_event_flags_set
 1085              	.L54:
 523:../cyfxbulksrcsink.c ****     }
 524:../cyfxbulksrcsink.c **** 
 525:../cyfxbulksrcsink.c ****     return isHandled;
 1086              		.loc 1 525 0
 1087 09b0 08301BE5 		ldr	r3, [fp, #-8]
 526:../cyfxbulksrcsink.c **** }
 1088              		.loc 1 526 0
 1089 09b4 0300A0E1 		mov	r0, r3
 1090 09b8 04D04BE2 		sub	sp, fp, #4
 1091 09bc 0088BDE8 		ldmfd	sp!, {fp, pc}
 1092              	.L56:
 1093              		.align	2
 1094              	.L55:
 1095 09c0 00000000 		.word	glIsApplnActive
 1096 09c4 00000000 		.word	glDataTransStarted
 1097 09c8 00000000 		.word	glForceLinkU2
 1098 09cc 00000000 		.word	glChHandleBulkSink
 1099 09d0 00000000 		.word	glChHandleBulkSrc
 1100 09d4 00000000 		.word	gl_setupdat0
 1101 09d8 00000000 		.word	gl_setupdat1
 1102 09dc 00000000 		.word	glBulkLpEvent
 1103              		.cfi_endproc
 1104              	.LFE5:
 1106              		.section	.rodata
 1107              		.align	2
 1108              	.LC7:
 1109 014c 43595F55 		.ascii	"CY_U3P_USB_EVENT_CONNECT detected (%d)\012\000"
 1109      33505F55 
 1109      53425F45 
 1109      56454E54 
 1109      5F434F4E 
 1110              		.align	2
 1111              	.LC8:
 1112 0174 43595F55 		.ascii	"CY_U3P_USB_EVENT_DISCONNECT detected (%d)\012\000"
 1112      33505F55 
 1112      53425F45 
 1112      56454E54 
 1112      5F444953 
 1113              		.text
 1114              		.align	2
 1115              		.global	CyFxBulkSrcSinkApplnUSBEventCB
 1117              	CyFxBulkSrcSinkApplnUSBEventCB:
 1118              	.LFB6:
 527:../cyfxbulksrcsink.c **** 
 528:../cyfxbulksrcsink.c **** /* This is the callback function to handle the USB events. */
 529:../cyfxbulksrcsink.c **** void
 530:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnUSBEventCB (
 531:../cyfxbulksrcsink.c ****     CyU3PUsbEventType_t evtype, /* Event type */
 532:../cyfxbulksrcsink.c ****     uint16_t            evdata  /* Event data */
 533:../cyfxbulksrcsink.c ****     )
 534:../cyfxbulksrcsink.c **** {
 1119              		.loc 1 534 0
 1120              		.cfi_startproc
 1121              		@ args = 0, pretend = 0, frame = 8
 1122              		@ frame_needed = 1, uses_anonymous_args = 0
 1123 09e0 00482DE9 		stmfd	sp!, {fp, lr}
 1124              	.LCFI12:
 1125              		.cfi_def_cfa_offset 8
 1126 09e4 04B08DE2 		add	fp, sp, #4
 1127              		.cfi_offset 14, -4
 1128              		.cfi_offset 11, -8
 1129              	.LCFI13:
 1130              		.cfi_def_cfa 11, 4
 1131 09e8 08D04DE2 		sub	sp, sp, #8
 1132 09ec 0020A0E1 		mov	r2, r0
 1133 09f0 0130A0E1 		mov	r3, r1
 1134 09f4 05204BE5 		strb	r2, [fp, #-5]
 1135 09f8 B8304BE1 		strh	r3, [fp, #-8]	@ movhi
 535:../cyfxbulksrcsink.c ****     static uint32_t num_connect    = 0;
 536:../cyfxbulksrcsink.c ****     static uint32_t num_disconnect = 0;
 537:../cyfxbulksrcsink.c **** 
 538:../cyfxbulksrcsink.c ****     switch (evtype)
 1136              		.loc 1 538 0
 1137 09fc 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1138 0a00 0C0053E3 		cmp	r3, #12
 1139 0a04 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1140 0a08 4A0000EA 		b	.L70
 1141              	.L64:
 1142 0a0c 400A0000 		.word	.L59
 1143 0a10 8C0A0000 		.word	.L60
 1144 0a14 380B0000 		.word	.L70
 1145 0a18 380B0000 		.word	.L70
 1146 0a1c 8C0A0000 		.word	.L60
 1147 0a20 700A0000 		.word	.L61
 1148 0a24 380B0000 		.word	.L70
 1149 0a28 380B0000 		.word	.L70
 1150 0a2c 380B0000 		.word	.L70
 1151 0a30 380B0000 		.word	.L70
 1152 0a34 F40A0000 		.word	.L62
 1153 0a38 380B0000 		.word	.L70
 1154 0a3c 0C0B0000 		.word	.L63
 1155              	.L59:
 539:../cyfxbulksrcsink.c ****     {
 540:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_CONNECT:
 541:../cyfxbulksrcsink.c ****       ++num_connect;
 1156              		.loc 1 541 0
 1157 0a40 0C319FE5 		ldr	r3, .L73
 1158 0a44 003093E5 		ldr	r3, [r3, #0]
 1159 0a48 012083E2 		add	r2, r3, #1
 1160 0a4c 00319FE5 		ldr	r3, .L73
 1161 0a50 002083E5 		str	r2, [r3, #0]
 542:../cyfxbulksrcsink.c ****       CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_CONNECT detected (%d)\n",
 1162              		.loc 1 542 0
 1163 0a54 F8309FE5 		ldr	r3, .L73
 1164 0a58 003093E5 		ldr	r3, [r3, #0]
 1165 0a5c 0800A0E3 		mov	r0, #8
 1166 0a60 F0109FE5 		ldr	r1, .L73+4
 1167 0a64 0320A0E1 		mov	r2, r3
 1168 0a68 FEFFFFEB 		bl	CyU3PDebugPrint
 543:../cyfxbulksrcsink.c ****                        num_connect);
 544:../cyfxbulksrcsink.c ****       break;
 1169              		.loc 1 544 0
 1170 0a6c 360000EA 		b	.L57
 1171              	.L61:
 545:../cyfxbulksrcsink.c **** 
 546:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_SETCONF:
 547:../cyfxbulksrcsink.c ****         /* If the application is already active
 548:../cyfxbulksrcsink.c ****          * stop it before re-enabling. */
 549:../cyfxbulksrcsink.c ****         if (glIsApplnActive)
 1172              		.loc 1 549 0
 1173 0a70 E4309FE5 		ldr	r3, .L73+8
 1174 0a74 003093E5 		ldr	r3, [r3, #0]
 1175 0a78 000053E3 		cmp	r3, #0
 1176 0a7c 0000000A 		beq	.L66
 550:../cyfxbulksrcsink.c ****         {
 551:../cyfxbulksrcsink.c ****             CyFxBulkSrcSinkApplnStop ();
 1177              		.loc 1 551 0
 1178 0a80 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 1179              	.L66:
 552:../cyfxbulksrcsink.c ****         }
 553:../cyfxbulksrcsink.c **** 
 554:../cyfxbulksrcsink.c ****         /* Start the source sink function. */
 555:../cyfxbulksrcsink.c ****         CyFxBulkSrcSinkApplnStart ();
 1180              		.loc 1 555 0
 1181 0a84 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStart
 556:../cyfxbulksrcsink.c ****         break;
 1182              		.loc 1 556 0
 1183 0a88 2F0000EA 		b	.L57
 1184              	.L60:
 557:../cyfxbulksrcsink.c **** 
 558:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_RESET:
 559:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_DISCONNECT:
 560:../cyfxbulksrcsink.c ****         glForceLinkU2 = CyFalse;
 1185              		.loc 1 560 0
 1186 0a8c CC309FE5 		ldr	r3, .L73+12
 1187 0a90 0020A0E3 		mov	r2, #0
 1188 0a94 002083E5 		str	r2, [r3, #0]
 561:../cyfxbulksrcsink.c **** 
 562:../cyfxbulksrcsink.c ****         /* Stop the source sink function. */
 563:../cyfxbulksrcsink.c ****         if (glIsApplnActive)
 1189              		.loc 1 563 0
 1190 0a98 BC309FE5 		ldr	r3, .L73+8
 1191 0a9c 003093E5 		ldr	r3, [r3, #0]
 1192 0aa0 000053E3 		cmp	r3, #0
 1193 0aa4 0000000A 		beq	.L67
 564:../cyfxbulksrcsink.c ****         {
 565:../cyfxbulksrcsink.c ****             CyFxBulkSrcSinkApplnStop ();
 1194              		.loc 1 565 0
 1195 0aa8 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 1196              	.L67:
 566:../cyfxbulksrcsink.c ****         }
 567:../cyfxbulksrcsink.c ****         glDataTransStarted = CyFalse;
 1197              		.loc 1 567 0
 1198 0aac B0309FE5 		ldr	r3, .L73+16
 1199 0ab0 0020A0E3 		mov	r2, #0
 1200 0ab4 002083E5 		str	r2, [r3, #0]
 568:../cyfxbulksrcsink.c **** 
 569:../cyfxbulksrcsink.c ****         if (evtype == CY_U3P_USB_EVENT_DISCONNECT) {
 1201              		.loc 1 569 0
 1202 0ab8 05305BE5 		ldrb	r3, [fp, #-5]	@ zero_extendqisi2
 1203 0abc 010053E3 		cmp	r3, #1
 1204 0ac0 1E00001A 		bne	.L71
 570:../cyfxbulksrcsink.c ****             ++num_disconnect;
 1205              		.loc 1 570 0
 1206 0ac4 9C309FE5 		ldr	r3, .L73+20
 1207 0ac8 003093E5 		ldr	r3, [r3, #0]
 1208 0acc 012083E2 		add	r2, r3, #1
 1209 0ad0 90309FE5 		ldr	r3, .L73+20
 1210 0ad4 002083E5 		str	r2, [r3, #0]
 571:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (8, "CY_U3P_USB_EVENT_DISCONNECT detected (%d)\n",
 1211              		.loc 1 571 0
 1212 0ad8 88309FE5 		ldr	r3, .L73+20
 1213 0adc 003093E5 		ldr	r3, [r3, #0]
 1214 0ae0 0800A0E3 		mov	r0, #8
 1215 0ae4 80109FE5 		ldr	r1, .L73+24
 1216 0ae8 0320A0E1 		mov	r2, r3
 1217 0aec FEFFFFEB 		bl	CyU3PDebugPrint
 572:../cyfxbulksrcsink.c ****                              num_disconnect);
 573:../cyfxbulksrcsink.c ****         }
 574:../cyfxbulksrcsink.c ****         break;
 1218              		.loc 1 574 0
 1219 0af0 150000EA 		b	.L57
 1220              	.L62:
 575:../cyfxbulksrcsink.c **** 
 576:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_EP0_STAT_CPLT:
 577:../cyfxbulksrcsink.c ****         glEp0StatCount++;
 1221              		.loc 1 577 0
 1222 0af4 74309FE5 		ldr	r3, .L73+28
 1223 0af8 003093E5 		ldr	r3, [r3, #0]
 1224 0afc 012083E2 		add	r2, r3, #1
 1225 0b00 68309FE5 		ldr	r3, .L73+28
 1226 0b04 002083E5 		str	r2, [r3, #0]
 578:../cyfxbulksrcsink.c ****         break;
 1227              		.loc 1 578 0
 1228 0b08 0F0000EA 		b	.L57
 1229              	.L63:
 579:../cyfxbulksrcsink.c **** 
 580:../cyfxbulksrcsink.c ****     case CY_U3P_USB_EVENT_VBUS_REMOVED:
 581:../cyfxbulksrcsink.c ****         if (StandbyModeEnable)
 1230              		.loc 1 581 0
 1231 0b0c 60309FE5 		ldr	r3, .L73+32
 1232 0b10 003093E5 		ldr	r3, [r3, #0]
 1233 0b14 000053E3 		cmp	r3, #0
 1234 0b18 0A00000A 		beq	.L72
 582:../cyfxbulksrcsink.c ****         {
 583:../cyfxbulksrcsink.c ****             TriggerStandbyMode = CyTrue;
 1235              		.loc 1 583 0
 1236 0b1c 54309FE5 		ldr	r3, .L73+36
 1237 0b20 0120A0E3 		mov	r2, #1
 1238 0b24 002083E5 		str	r2, [r3, #0]
 584:../cyfxbulksrcsink.c ****             StandbyModeEnable  = CyFalse;
 1239              		.loc 1 584 0
 1240 0b28 44309FE5 		ldr	r3, .L73+32
 1241 0b2c 0020A0E3 		mov	r2, #0
 1242 0b30 002083E5 		str	r2, [r3, #0]
 585:../cyfxbulksrcsink.c ****         }
 586:../cyfxbulksrcsink.c ****         break;
 1243              		.loc 1 586 0
 1244 0b34 040000EA 		b	.L57
 1245              	.L70:
 587:../cyfxbulksrcsink.c **** 
 588:../cyfxbulksrcsink.c ****     default:
 589:../cyfxbulksrcsink.c ****         break;
 1246              		.loc 1 589 0
 1247 0b38 0000A0E1 		mov	r0, r0	@ nop
 1248 0b3c 020000EA 		b	.L57
 1249              	.L71:
 574:../cyfxbulksrcsink.c ****         break;
 1250              		.loc 1 574 0
 1251 0b40 0000A0E1 		mov	r0, r0	@ nop
 1252 0b44 000000EA 		b	.L57
 1253              	.L72:
 586:../cyfxbulksrcsink.c ****         break;
 1254              		.loc 1 586 0
 1255 0b48 0000A0E1 		mov	r0, r0	@ nop
 1256              	.L57:
 590:../cyfxbulksrcsink.c ****     }
 591:../cyfxbulksrcsink.c **** }
 1257              		.loc 1 591 0
 1258 0b4c 04D04BE2 		sub	sp, fp, #4
 1259 0b50 0088BDE8 		ldmfd	sp!, {fp, pc}
 1260              	.L74:
 1261              		.align	2
 1262              	.L73:
 1263 0b54 24000000 		.word	num_connect.6776
 1264 0b58 4C010000 		.word	.LC7
 1265 0b5c 00000000 		.word	glIsApplnActive
 1266 0b60 00000000 		.word	glForceLinkU2
 1267 0b64 00000000 		.word	glDataTransStarted
 1268 0b68 28000000 		.word	num_disconnect.6777
 1269 0b6c 74010000 		.word	.LC8
 1270 0b70 00000000 		.word	glEp0StatCount
 1271 0b74 00000000 		.word	StandbyModeEnable
 1272 0b78 00000000 		.word	TriggerStandbyMode
 1273              		.cfi_endproc
 1274              	.LFE6:
 1276              		.align	2
 1277              		.global	CyFxBulkSrcSinkApplnLPMRqtCB
 1279              	CyFxBulkSrcSinkApplnLPMRqtCB:
 1280              	.LFB7:
 592:../cyfxbulksrcsink.c **** 
 593:../cyfxbulksrcsink.c **** /* Callback function to handle LPM requests from the USB 3.0 host. This function is invoked by the 
 594:../cyfxbulksrcsink.c ****    whenever a state change from U0 -> U1 or U0 -> U2 happens. If we return CyTrue from this functio
 595:../cyfxbulksrcsink.c ****    FX3 device is retained in the low power state. If we return CyFalse, the FX3 device immediately 
 596:../cyfxbulksrcsink.c ****    to trigger an exit back to U0.
 597:../cyfxbulksrcsink.c **** 
 598:../cyfxbulksrcsink.c ****    This application does not have any state in which we should not allow U1/U2 transitions; and the
 599:../cyfxbulksrcsink.c ****    the function always return CyTrue.
 600:../cyfxbulksrcsink.c ****  */
 601:../cyfxbulksrcsink.c **** CyBool_t
 602:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnLPMRqtCB (
 603:../cyfxbulksrcsink.c ****         CyU3PUsbLinkPowerMode link_mode)
 604:../cyfxbulksrcsink.c **** {
 1281              		.loc 1 604 0
 1282              		.cfi_startproc
 1283              		@ args = 0, pretend = 0, frame = 8
 1284              		@ frame_needed = 1, uses_anonymous_args = 0
 1285              		@ link register save eliminated.
 1286 0b7c 04B02DE5 		str	fp, [sp, #-4]!
 1287              	.LCFI14:
 1288              		.cfi_def_cfa_offset 4
 1289 0b80 00B08DE2 		add	fp, sp, #0
 1290              		.cfi_offset 11, -4
 1291              	.LCFI15:
 1292              		.cfi_def_cfa_register 11
 1293 0b84 0CD04DE2 		sub	sp, sp, #12
 1294 0b88 0030A0E1 		mov	r3, r0
 1295 0b8c 05304BE5 		strb	r3, [fp, #-5]
 605:../cyfxbulksrcsink.c ****     return CyTrue;
 1296              		.loc 1 605 0
 1297 0b90 0130A0E3 		mov	r3, #1
 606:../cyfxbulksrcsink.c **** }
 1298              		.loc 1 606 0
 1299 0b94 0300A0E1 		mov	r0, r3
 1300 0b98 00D08BE2 		add	sp, fp, #0
 1301 0b9c 04B09DE4 		ldmfd	sp!, {fp}
 1302 0ba0 1EFF2FE1 		bx	lr
 1303              		.cfi_endproc
 1304              	.LFE7:
 1306              		.section	.rodata
 1307 019f 00       		.align	2
 1308              	.LC9:
 1309 01a0 43795533 		.ascii	"CyU3PUsbStart failed to Start, Error code = %d\012\000"
 1309      50557362 
 1309      53746172 
 1309      74206661 
 1309      696C6564 
 1310              		.align	2
 1311              	.LC10:
 1312 01d0 55534220 		.ascii	"USB set device descriptor failed, Error code = %d\012"
 1312      73657420 
 1312      64657669 
 1312      63652064 
 1312      65736372 
 1313 0202 00       		.ascii	"\000"
 1314 0203 00       		.align	2
 1315              	.LC11:
 1316 0204 55534220 		.ascii	"USB set configuration descriptor failed, Error code"
 1316      73657420 
 1316      636F6E66 
 1316      69677572 
 1316      6174696F 
 1317 0237 203D2025 		.ascii	" = %d\012\000"
 1317      640A00
 1318 023e 0000     		.align	2
 1319              	.LC12:
 1320 0240 55534220 		.ascii	"USB set device qualifier descriptor failed, Error c"
 1320      73657420 
 1320      64657669 
 1320      63652071 
 1320      75616C69 
 1321 0273 6F646520 		.ascii	"ode = %d\012\000"
 1321      3D202564 
 1321      0A00
 1322 027d 000000   		.align	2
 1323              	.LC13:
 1324 0280 55534220 		.ascii	"USB Set Other Speed Descriptor failed, Error Code ="
 1324      53657420 
 1324      4F746865 
 1324      72205370 
 1324      65656420 
 1325 02b3 2025640A 		.ascii	" %d\012\000"
 1325      00
 1326              		.align	2
 1327              	.LC14:
 1328 02b8 55534220 		.ascii	"USB Set Configuration Descriptor failed, Error Code"
 1328      53657420 
 1328      436F6E66 
 1328      69677572 
 1328      6174696F 
 1329 02eb 203D2025 		.ascii	" = %d\012\000"
 1329      640A00
 1330 02f2 0000     		.align	2
 1331              	.LC15:
 1332 02f4 55534220 		.ascii	"USB set string descriptor failed, Error code = %d\012"
 1332      73657420 
 1332      73747269 
 1332      6E672064 
 1332      65736372 
 1333 0326 00       		.ascii	"\000"
 1334 0327 00       		.align	2
 1335              	.LC16:
 1336 0328 41626F75 		.ascii	"About to connect to USB host\015\012\000"
 1336      7420746F 
 1336      20636F6E 
 1336      6E656374 
 1336      20746F20 
 1337 0347 00       		.align	2
 1338              	.LC17:
 1339 0348 55534220 		.ascii	"USB Connect failed, Error code = %d\012\000"
 1339      436F6E6E 
 1339      65637420 
 1339      6661696C 
 1339      65642C20 
 1340 036d 000000   		.align	2
 1341              	.LC18:
 1342 0370 43794678 		.ascii	"CyFxBulkSrcSinkApplnInit complete\015\012\000"
 1342      42756C6B 
 1342      53726353 
 1342      696E6B41 
 1342      70706C6E 
 1343              		.text
 1344              		.align	2
 1345              		.global	CyFxBulkSrcSinkApplnInit
 1347              	CyFxBulkSrcSinkApplnInit:
 1348              	.LFB8:
 607:../cyfxbulksrcsink.c **** 
 608:../cyfxbulksrcsink.c **** /* This function initializes the USB Module, sets the enumeration descriptors.
 609:../cyfxbulksrcsink.c ****  * This function does not start the bulk streaming and this is done only when
 610:../cyfxbulksrcsink.c ****  * SET_CONF event is received. */
 611:../cyfxbulksrcsink.c **** void
 612:../cyfxbulksrcsink.c **** CyFxBulkSrcSinkApplnInit (void)
 613:../cyfxbulksrcsink.c **** {
 1349              		.loc 1 613 0
 1350              		.cfi_startproc
 1351              		@ args = 0, pretend = 0, frame = 8
 1352              		@ frame_needed = 1, uses_anonymous_args = 0
 1353 0ba4 00482DE9 		stmfd	sp!, {fp, lr}
 1354              	.LCFI16:
 1355              		.cfi_def_cfa_offset 8
 1356 0ba8 04B08DE2 		add	fp, sp, #4
 1357              		.cfi_offset 14, -4
 1358              		.cfi_offset 11, -8
 1359              	.LCFI17:
 1360              		.cfi_def_cfa 11, 4
 1361 0bac 08D04DE2 		sub	sp, sp, #8
 614:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t apiRetStatus = CY_U3P_SUCCESS;
 1362              		.loc 1 614 0
 1363 0bb0 0030A0E3 		mov	r3, #0
 1364 0bb4 0C300BE5 		str	r3, [fp, #-12]
 615:../cyfxbulksrcsink.c ****     CyBool_t no_renum = CyFalse;
 1365              		.loc 1 615 0
 1366 0bb8 0030A0E3 		mov	r3, #0
 1367 0bbc 08300BE5 		str	r3, [fp, #-8]
 616:../cyfxbulksrcsink.c **** 
 617:../cyfxbulksrcsink.c ****     /* Start the USB functionality. */
 618:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbStart();
 1368              		.loc 1 618 0
 1369 0bc0 FEFFFFEB 		bl	CyU3PUsbStart
 1370 0bc4 0C000BE5 		str	r0, [fp, #-12]
 619:../cyfxbulksrcsink.c ****     if (apiRetStatus == CY_U3P_ERROR_NO_REENUM_REQUIRED)
 1371              		.loc 1 619 0
 1372 0bc8 0C301BE5 		ldr	r3, [fp, #-12]
 1373 0bcc FE0053E3 		cmp	r3, #254
 1374 0bd0 0200001A 		bne	.L77
 620:../cyfxbulksrcsink.c ****         no_renum = CyTrue;
 1375              		.loc 1 620 0
 1376 0bd4 0130A0E3 		mov	r3, #1
 1377 0bd8 08300BE5 		str	r3, [fp, #-8]
 1378 0bdc 080000EA 		b	.L78
 1379              	.L77:
 621:../cyfxbulksrcsink.c ****     else if (apiRetStatus != CY_U3P_SUCCESS)
 1380              		.loc 1 621 0
 1381 0be0 0C301BE5 		ldr	r3, [fp, #-12]
 1382 0be4 000053E3 		cmp	r3, #0
 1383 0be8 0500000A 		beq	.L78
 622:../cyfxbulksrcsink.c ****     {
 623:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "CyU3PUsbStart failed to Start, Error code = %d\n", apiRetStatus);
 1384              		.loc 1 623 0
 1385 0bec 0400A0E3 		mov	r0, #4
 1386 0bf0 10139FE5 		ldr	r1, .L93
 1387 0bf4 0C201BE5 		ldr	r2, [fp, #-12]
 1388 0bf8 FEFFFFEB 		bl	CyU3PDebugPrint
 624:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1389              		.loc 1 624 0
 1390 0bfc 0C001BE5 		ldr	r0, [fp, #-12]
 1391 0c00 FEFFFFEB 		bl	CyFxAppErrorHandler
 1392              	.L78:
 625:../cyfxbulksrcsink.c ****     }
 626:../cyfxbulksrcsink.c **** 
 627:../cyfxbulksrcsink.c ****     /* The fast enumeration is the easiest way to setup a USB connection,
 628:../cyfxbulksrcsink.c ****      * where all enumeration phase is handled by the library. Only the
 629:../cyfxbulksrcsink.c ****      * class / vendor requests need to be handled by the application. */
 630:../cyfxbulksrcsink.c ****     CyU3PUsbRegisterSetupCallback(CyFxBulkSrcSinkApplnUSBSetupCB, CyTrue);
 1393              		.loc 1 630 0
 1394 0c04 00039FE5 		ldr	r0, .L93+4
 1395 0c08 0110A0E3 		mov	r1, #1
 1396 0c0c FEFFFFEB 		bl	CyU3PUsbRegisterSetupCallback
 631:../cyfxbulksrcsink.c **** 
 632:../cyfxbulksrcsink.c ****     /* Setup the callback to handle the USB events. */
 633:../cyfxbulksrcsink.c ****     CyU3PUsbRegisterEventCallback(CyFxBulkSrcSinkApplnUSBEventCB);
 1397              		.loc 1 633 0
 1398 0c10 F8029FE5 		ldr	r0, .L93+8
 1399 0c14 FEFFFFEB 		bl	CyU3PUsbRegisterEventCallback
 634:../cyfxbulksrcsink.c **** 
 635:../cyfxbulksrcsink.c ****     /* Register a callback to handle LPM requests from the USB 3.0 host. */
 636:../cyfxbulksrcsink.c ****     CyU3PUsbRegisterLPMRequestCallback(CyFxBulkSrcSinkApplnLPMRqtCB);
 1400              		.loc 1 636 0
 1401 0c18 F4029FE5 		ldr	r0, .L93+12
 1402 0c1c FEFFFFEB 		bl	CyU3PUsbRegisterLPMRequestCallback
 637:../cyfxbulksrcsink.c **** 
 638:../cyfxbulksrcsink.c ****     /* Set the USB Enumeration descriptors */
 639:../cyfxbulksrcsink.c **** 
 640:../cyfxbulksrcsink.c ****     /* Super speed device descriptor. */
 641:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSB30Device
 1403              		.loc 1 641 0
 1404 0c20 0000A0E3 		mov	r0, #0
 1405 0c24 0010A0E3 		mov	r1, #0
 1406 0c28 E8229FE5 		ldr	r2, .L93+16
 1407 0c2c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1408 0c30 0C000BE5 		str	r0, [fp, #-12]
 642:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1409              		.loc 1 642 0
 1410 0c34 0C301BE5 		ldr	r3, [fp, #-12]
 1411 0c38 000053E3 		cmp	r3, #0
 1412 0c3c 0500000A 		beq	.L79
 643:../cyfxbulksrcsink.c ****     {
 644:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", apiRetStatus);
 1413              		.loc 1 644 0
 1414 0c40 0400A0E3 		mov	r0, #4
 1415 0c44 D0129FE5 		ldr	r1, .L93+20
 1416 0c48 0C201BE5 		ldr	r2, [fp, #-12]
 1417 0c4c FEFFFFEB 		bl	CyU3PDebugPrint
 645:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1418              		.loc 1 645 0
 1419 0c50 0C001BE5 		ldr	r0, [fp, #-12]
 1420 0c54 FEFFFFEB 		bl	CyFxAppErrorHandler
 1421              	.L79:
 646:../cyfxbulksrcsink.c ****     }
 647:../cyfxbulksrcsink.c **** 
 648:../cyfxbulksrcsink.c ****     /* High speed device descriptor. */
 649:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_DEVICE_DESCR, NULL, (uint8_t *)CyFxUSB20Device
 1422              		.loc 1 649 0
 1423 0c58 0100A0E3 		mov	r0, #1
 1424 0c5c 0010A0E3 		mov	r1, #0
 1425 0c60 B8229FE5 		ldr	r2, .L93+24
 1426 0c64 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1427 0c68 0C000BE5 		str	r0, [fp, #-12]
 650:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1428              		.loc 1 650 0
 1429 0c6c 0C301BE5 		ldr	r3, [fp, #-12]
 1430 0c70 000053E3 		cmp	r3, #0
 1431 0c74 0500000A 		beq	.L80
 651:../cyfxbulksrcsink.c ****     {
 652:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set device descriptor failed, Error code = %d\n", apiRetStatus);
 1432              		.loc 1 652 0
 1433 0c78 0400A0E3 		mov	r0, #4
 1434 0c7c 98129FE5 		ldr	r1, .L93+20
 1435 0c80 0C201BE5 		ldr	r2, [fp, #-12]
 1436 0c84 FEFFFFEB 		bl	CyU3PDebugPrint
 653:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1437              		.loc 1 653 0
 1438 0c88 0C001BE5 		ldr	r0, [fp, #-12]
 1439 0c8c FEFFFFEB 		bl	CyFxAppErrorHandler
 1440              	.L80:
 654:../cyfxbulksrcsink.c ****     }
 655:../cyfxbulksrcsink.c **** 
 656:../cyfxbulksrcsink.c ****     /* BOS descriptor */
 657:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_BOS_DESCR, NULL, (uint8_t *)CyFxUSBBOSDscr);
 1441              		.loc 1 657 0
 1442 0c90 0700A0E3 		mov	r0, #7
 1443 0c94 0010A0E3 		mov	r1, #0
 1444 0c98 84229FE5 		ldr	r2, .L93+28
 1445 0c9c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1446 0ca0 0C000BE5 		str	r0, [fp, #-12]
 658:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1447              		.loc 1 658 0
 1448 0ca4 0C301BE5 		ldr	r3, [fp, #-12]
 1449 0ca8 000053E3 		cmp	r3, #0
 1450 0cac 0500000A 		beq	.L81
 659:../cyfxbulksrcsink.c ****     {
 660:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", apiRetSta
 1451              		.loc 1 660 0
 1452 0cb0 0400A0E3 		mov	r0, #4
 1453 0cb4 6C129FE5 		ldr	r1, .L93+32
 1454 0cb8 0C201BE5 		ldr	r2, [fp, #-12]
 1455 0cbc FEFFFFEB 		bl	CyU3PDebugPrint
 661:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1456              		.loc 1 661 0
 1457 0cc0 0C001BE5 		ldr	r0, [fp, #-12]
 1458 0cc4 FEFFFFEB 		bl	CyFxAppErrorHandler
 1459              	.L81:
 662:../cyfxbulksrcsink.c ****     }
 663:../cyfxbulksrcsink.c **** 
 664:../cyfxbulksrcsink.c ****     /* Device qualifier descriptor */
 665:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_DEVQUAL_DESCR, NULL, (uint8_t *)CyFxUSBDeviceQual
 1460              		.loc 1 665 0
 1461 0cc8 0200A0E3 		mov	r0, #2
 1462 0ccc 0010A0E3 		mov	r1, #0
 1463 0cd0 54229FE5 		ldr	r2, .L93+36
 1464 0cd4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1465 0cd8 0C000BE5 		str	r0, [fp, #-12]
 666:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1466              		.loc 1 666 0
 1467 0cdc 0C301BE5 		ldr	r3, [fp, #-12]
 1468 0ce0 000053E3 		cmp	r3, #0
 1469 0ce4 0500000A 		beq	.L82
 667:../cyfxbulksrcsink.c ****     {
 668:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set device qualifier descriptor failed, Error code = %d\n", apiRet
 1470              		.loc 1 668 0
 1471 0ce8 0400A0E3 		mov	r0, #4
 1472 0cec 3C129FE5 		ldr	r1, .L93+40
 1473 0cf0 0C201BE5 		ldr	r2, [fp, #-12]
 1474 0cf4 FEFFFFEB 		bl	CyU3PDebugPrint
 669:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1475              		.loc 1 669 0
 1476 0cf8 0C001BE5 		ldr	r0, [fp, #-12]
 1477 0cfc FEFFFFEB 		bl	CyFxAppErrorHandler
 1478              	.L82:
 670:../cyfxbulksrcsink.c ****     }
 671:../cyfxbulksrcsink.c **** 
 672:../cyfxbulksrcsink.c ****     /* Super speed configuration descriptor */
 673:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_SS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBSSConfig
 1479              		.loc 1 673 0
 1480 0d00 0600A0E3 		mov	r0, #6
 1481 0d04 0010A0E3 		mov	r1, #0
 1482 0d08 24229FE5 		ldr	r2, .L93+44
 1483 0d0c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1484 0d10 0C000BE5 		str	r0, [fp, #-12]
 674:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1485              		.loc 1 674 0
 1486 0d14 0C301BE5 		ldr	r3, [fp, #-12]
 1487 0d18 000053E3 		cmp	r3, #0
 1488 0d1c 0500000A 		beq	.L83
 675:../cyfxbulksrcsink.c ****     {
 676:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set configuration descriptor failed, Error code = %d\n", apiRetSta
 1489              		.loc 1 676 0
 1490 0d20 0400A0E3 		mov	r0, #4
 1491 0d24 FC119FE5 		ldr	r1, .L93+32
 1492 0d28 0C201BE5 		ldr	r2, [fp, #-12]
 1493 0d2c FEFFFFEB 		bl	CyU3PDebugPrint
 677:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1494              		.loc 1 677 0
 1495 0d30 0C001BE5 		ldr	r0, [fp, #-12]
 1496 0d34 FEFFFFEB 		bl	CyFxAppErrorHandler
 1497              	.L83:
 678:../cyfxbulksrcsink.c ****     }
 679:../cyfxbulksrcsink.c **** 
 680:../cyfxbulksrcsink.c ****     /* High speed configuration descriptor */
 681:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_HS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBHSConfig
 1498              		.loc 1 681 0
 1499 0d38 0400A0E3 		mov	r0, #4
 1500 0d3c 0010A0E3 		mov	r1, #0
 1501 0d40 F0219FE5 		ldr	r2, .L93+48
 1502 0d44 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1503 0d48 0C000BE5 		str	r0, [fp, #-12]
 682:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1504              		.loc 1 682 0
 1505 0d4c 0C301BE5 		ldr	r3, [fp, #-12]
 1506 0d50 000053E3 		cmp	r3, #0
 1507 0d54 0500000A 		beq	.L84
 683:../cyfxbulksrcsink.c ****     {
 684:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB Set Other Speed Descriptor failed, Error Code = %d\n", apiRetStatu
 1508              		.loc 1 684 0
 1509 0d58 0400A0E3 		mov	r0, #4
 1510 0d5c D8119FE5 		ldr	r1, .L93+52
 1511 0d60 0C201BE5 		ldr	r2, [fp, #-12]
 1512 0d64 FEFFFFEB 		bl	CyU3PDebugPrint
 685:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1513              		.loc 1 685 0
 1514 0d68 0C001BE5 		ldr	r0, [fp, #-12]
 1515 0d6c FEFFFFEB 		bl	CyFxAppErrorHandler
 1516              	.L84:
 686:../cyfxbulksrcsink.c ****     }
 687:../cyfxbulksrcsink.c **** 
 688:../cyfxbulksrcsink.c ****     /* Full speed configuration descriptor */
 689:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_FS_CONFIG_DESCR, NULL, (uint8_t *)CyFxUSBFSConfig
 1517              		.loc 1 689 0
 1518 0d70 0300A0E3 		mov	r0, #3
 1519 0d74 0010A0E3 		mov	r1, #0
 1520 0d78 C0219FE5 		ldr	r2, .L93+56
 1521 0d7c FEFFFFEB 		bl	CyU3PUsbSetDesc
 1522 0d80 0C000BE5 		str	r0, [fp, #-12]
 690:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1523              		.loc 1 690 0
 1524 0d84 0C301BE5 		ldr	r3, [fp, #-12]
 1525 0d88 000053E3 		cmp	r3, #0
 1526 0d8c 0500000A 		beq	.L85
 691:../cyfxbulksrcsink.c ****     {
 692:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB Set Configuration Descriptor failed, Error Code = %d\n", apiRetSta
 1527              		.loc 1 692 0
 1528 0d90 0400A0E3 		mov	r0, #4
 1529 0d94 A8119FE5 		ldr	r1, .L93+60
 1530 0d98 0C201BE5 		ldr	r2, [fp, #-12]
 1531 0d9c FEFFFFEB 		bl	CyU3PDebugPrint
 693:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1532              		.loc 1 693 0
 1533 0da0 0C001BE5 		ldr	r0, [fp, #-12]
 1534 0da4 FEFFFFEB 		bl	CyFxAppErrorHandler
 1535              	.L85:
 694:../cyfxbulksrcsink.c ****     }
 695:../cyfxbulksrcsink.c **** 
 696:../cyfxbulksrcsink.c ****     /* String descriptor 0 */
 697:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 0, (uint8_t *)CyFxUSBStringLangIDDs
 1536              		.loc 1 697 0
 1537 0da8 0500A0E3 		mov	r0, #5
 1538 0dac 0010A0E3 		mov	r1, #0
 1539 0db0 90219FE5 		ldr	r2, .L93+64
 1540 0db4 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1541 0db8 0C000BE5 		str	r0, [fp, #-12]
 698:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1542              		.loc 1 698 0
 1543 0dbc 0C301BE5 		ldr	r3, [fp, #-12]
 1544 0dc0 000053E3 		cmp	r3, #0
 1545 0dc4 0500000A 		beq	.L86
 699:../cyfxbulksrcsink.c ****     {
 700:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1546              		.loc 1 700 0
 1547 0dc8 0400A0E3 		mov	r0, #4
 1548 0dcc 78119FE5 		ldr	r1, .L93+68
 1549 0dd0 0C201BE5 		ldr	r2, [fp, #-12]
 1550 0dd4 FEFFFFEB 		bl	CyU3PDebugPrint
 701:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1551              		.loc 1 701 0
 1552 0dd8 0C001BE5 		ldr	r0, [fp, #-12]
 1553 0ddc FEFFFFEB 		bl	CyFxAppErrorHandler
 1554              	.L86:
 702:../cyfxbulksrcsink.c ****     }
 703:../cyfxbulksrcsink.c **** 
 704:../cyfxbulksrcsink.c ****     /* String descriptor 1 */
 705:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 1, (uint8_t *)CyFxUSBManufactureDsc
 1555              		.loc 1 705 0
 1556 0de0 0500A0E3 		mov	r0, #5
 1557 0de4 0110A0E3 		mov	r1, #1
 1558 0de8 60219FE5 		ldr	r2, .L93+72
 1559 0dec FEFFFFEB 		bl	CyU3PUsbSetDesc
 1560 0df0 0C000BE5 		str	r0, [fp, #-12]
 706:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1561              		.loc 1 706 0
 1562 0df4 0C301BE5 		ldr	r3, [fp, #-12]
 1563 0df8 000053E3 		cmp	r3, #0
 1564 0dfc 0500000A 		beq	.L87
 707:../cyfxbulksrcsink.c ****     {
 708:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1565              		.loc 1 708 0
 1566 0e00 0400A0E3 		mov	r0, #4
 1567 0e04 40119FE5 		ldr	r1, .L93+68
 1568 0e08 0C201BE5 		ldr	r2, [fp, #-12]
 1569 0e0c FEFFFFEB 		bl	CyU3PDebugPrint
 709:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1570              		.loc 1 709 0
 1571 0e10 0C001BE5 		ldr	r0, [fp, #-12]
 1572 0e14 FEFFFFEB 		bl	CyFxAppErrorHandler
 1573              	.L87:
 710:../cyfxbulksrcsink.c ****     }
 711:../cyfxbulksrcsink.c **** 
 712:../cyfxbulksrcsink.c ****     /* String descriptor 2 */
 713:../cyfxbulksrcsink.c ****     apiRetStatus = CyU3PUsbSetDesc(CY_U3P_USB_SET_STRING_DESCR, 2, (uint8_t *)CyFxUSBProductDscr);
 1574              		.loc 1 713 0
 1575 0e18 0500A0E3 		mov	r0, #5
 1576 0e1c 0210A0E3 		mov	r1, #2
 1577 0e20 2C219FE5 		ldr	r2, .L93+76
 1578 0e24 FEFFFFEB 		bl	CyU3PUsbSetDesc
 1579 0e28 0C000BE5 		str	r0, [fp, #-12]
 714:../cyfxbulksrcsink.c ****     if (apiRetStatus != CY_U3P_SUCCESS)
 1580              		.loc 1 714 0
 1581 0e2c 0C301BE5 		ldr	r3, [fp, #-12]
 1582 0e30 000053E3 		cmp	r3, #0
 1583 0e34 0500000A 		beq	.L88
 715:../cyfxbulksrcsink.c ****     {
 716:../cyfxbulksrcsink.c ****         CyU3PDebugPrint (4, "USB set string descriptor failed, Error code = %d\n", apiRetStatus);
 1584              		.loc 1 716 0
 1585 0e38 0400A0E3 		mov	r0, #4
 1586 0e3c 08119FE5 		ldr	r1, .L93+68
 1587 0e40 0C201BE5 		ldr	r2, [fp, #-12]
 1588 0e44 FEFFFFEB 		bl	CyU3PDebugPrint
 717:../cyfxbulksrcsink.c ****         CyFxAppErrorHandler(apiRetStatus);
 1589              		.loc 1 717 0
 1590 0e48 0C001BE5 		ldr	r0, [fp, #-12]
 1591 0e4c FEFFFFEB 		bl	CyFxAppErrorHandler
 1592              	.L88:
 718:../cyfxbulksrcsink.c ****     }
 719:../cyfxbulksrcsink.c **** 
 720:../cyfxbulksrcsink.c ****     /* Register a buffer into which the USB driver can log relevant events. */
 721:../cyfxbulksrcsink.c ****     gl_UsbLogBuffer = (uint8_t *)CyU3PDmaBufferAlloc (CYFX_USBLOG_SIZE);
 1593              		.loc 1 721 0
 1594 0e50 010AA0E3 		mov	r0, #4096
 1595 0e54 FEFFFFEB 		bl	CyU3PDmaBufferAlloc
 1596 0e58 0030A0E1 		mov	r3, r0
 1597 0e5c 0320A0E1 		mov	r2, r3
 1598 0e60 F0309FE5 		ldr	r3, .L93+80
 1599 0e64 002083E5 		str	r2, [r3, #0]
 722:../cyfxbulksrcsink.c ****     if (gl_UsbLogBuffer)
 1600              		.loc 1 722 0
 1601 0e68 E8309FE5 		ldr	r3, .L93+80
 1602 0e6c 003093E5 		ldr	r3, [r3, #0]
 1603 0e70 000053E3 		cmp	r3, #0
 1604 0e74 0400000A 		beq	.L89
 723:../cyfxbulksrcsink.c ****         CyU3PUsbInitEventLog (gl_UsbLogBuffer, CYFX_USBLOG_SIZE);
 1605              		.loc 1 723 0
 1606 0e78 D8309FE5 		ldr	r3, .L93+80
 1607 0e7c 003093E5 		ldr	r3, [r3, #0]
 1608 0e80 0300A0E1 		mov	r0, r3
 1609 0e84 011AA0E3 		mov	r1, #4096
 1610 0e88 FEFFFFEB 		bl	CyU3PUsbInitEventLog
 1611              	.L89:
 724:../cyfxbulksrcsink.c **** 
 725:../cyfxbulksrcsink.c ****     CyU3PDebugPrint (4, "About to connect to USB host\r\n");
 1612              		.loc 1 725 0
 1613 0e8c 0400A0E3 		mov	r0, #4
 1614 0e90 C4109FE5 		ldr	r1, .L93+84
 1615 0e94 FEFFFFEB 		bl	CyU3PDebugPrint
 726:../cyfxbulksrcsink.c **** 
 727:../cyfxbulksrcsink.c ****     /* Connect the USB Pins with super speed operation enabled. */
 728:../cyfxbulksrcsink.c ****     if (!no_renum) {
 1616              		.loc 1 728 0
 1617 0e98 08301BE5 		ldr	r3, [fp, #-8]
 1618 0e9c 000053E3 		cmp	r3, #0
 1619 0ea0 0D00001A 		bne	.L90
 729:../cyfxbulksrcsink.c ****         apiRetStatus = CyU3PConnectState(CyTrue, CyTrue);
 1620              		.loc 1 729 0
 1621 0ea4 0100A0E3 		mov	r0, #1
 1622 0ea8 0110A0E3 		mov	r1, #1
 1623 0eac FEFFFFEB 		bl	CyU3PConnectState
 1624 0eb0 0C000BE5 		str	r0, [fp, #-12]
 730:../cyfxbulksrcsink.c ****         if (apiRetStatus != CY_U3P_SUCCESS)
 1625              		.loc 1 730 0
 1626 0eb4 0C301BE5 		ldr	r3, [fp, #-12]
 1627 0eb8 000053E3 		cmp	r3, #0
 1628 0ebc 0C00000A 		beq	.L91
 731:../cyfxbulksrcsink.c ****         {
 732:../cyfxbulksrcsink.c ****             CyU3PDebugPrint (4, "USB Connect failed, Error code = %d\n", apiRetStatus);
 1629              		.loc 1 732 0
 1630 0ec0 0400A0E3 		mov	r0, #4
 1631 0ec4 94109FE5 		ldr	r1, .L93+88
 1632 0ec8 0C201BE5 		ldr	r2, [fp, #-12]
 1633 0ecc FEFFFFEB 		bl	CyU3PDebugPrint
 733:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler(apiRetStatus);
 1634              		.loc 1 733 0
 1635 0ed0 0C001BE5 		ldr	r0, [fp, #-12]
 1636 0ed4 FEFFFFEB 		bl	CyFxAppErrorHandler
 1637 0ed8 050000EA 		b	.L91
 1638              	.L90:
 734:../cyfxbulksrcsink.c ****         }
 735:../cyfxbulksrcsink.c ****     }
 736:../cyfxbulksrcsink.c ****     else
 737:../cyfxbulksrcsink.c ****     {
 738:../cyfxbulksrcsink.c ****         /* USB connection is already active. Configure the endpoints and DMA channels. */
 739:../cyfxbulksrcsink.c ****         if (glIsApplnActive)
 1639              		.loc 1 739 0
 1640 0edc 80309FE5 		ldr	r3, .L93+92
 1641 0ee0 003093E5 		ldr	r3, [r3, #0]
 1642 0ee4 000053E3 		cmp	r3, #0
 1643 0ee8 0000000A 		beq	.L92
 740:../cyfxbulksrcsink.c ****             CyFxBulkSrcSinkApplnStop ();
 1644              		.loc 1 740 0
 1645 0eec FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 1646              	.L92:
 741:../cyfxbulksrcsink.c ****         CyFxBulkSrcSinkApplnStart ();
 1647              		.loc 1 741 0
 1648 0ef0 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStart
 1649              	.L91:
 742:../cyfxbulksrcsink.c ****     }
 743:../cyfxbulksrcsink.c ****     CyU3PDebugPrint (8, "CyFxBulkSrcSinkApplnInit complete\r\n");
 1650              		.loc 1 743 0
 1651 0ef4 0800A0E3 		mov	r0, #8
 1652 0ef8 68109FE5 		ldr	r1, .L93+96
 1653 0efc FEFFFFEB 		bl	CyU3PDebugPrint
 744:../cyfxbulksrcsink.c **** }
 1654              		.loc 1 744 0
 1655 0f00 04D04BE2 		sub	sp, fp, #4
 1656 0f04 0088BDE8 		ldmfd	sp!, {fp, pc}
 1657              	.L94:
 1658              		.align	2
 1659              	.L93:
 1660 0f08 A0010000 		.word	.LC9
 1661 0f0c 00000000 		.word	CyFxBulkSrcSinkApplnUSBSetupCB
 1662 0f10 00000000 		.word	CyFxBulkSrcSinkApplnUSBEventCB
 1663 0f14 00000000 		.word	CyFxBulkSrcSinkApplnLPMRqtCB
 1664 0f18 00000000 		.word	CyFxUSB30DeviceDscr
 1665 0f1c D0010000 		.word	.LC10
 1666 0f20 00000000 		.word	CyFxUSB20DeviceDscr
 1667 0f24 00000000 		.word	CyFxUSBBOSDscr
 1668 0f28 04020000 		.word	.LC11
 1669 0f2c 00000000 		.word	CyFxUSBDeviceQualDscr
 1670 0f30 40020000 		.word	.LC12
 1671 0f34 00000000 		.word	CyFxUSBSSConfigDscr
 1672 0f38 00000000 		.word	CyFxUSBHSConfigDscr
 1673 0f3c 80020000 		.word	.LC13
 1674 0f40 00000000 		.word	CyFxUSBFSConfigDscr
 1675 0f44 B8020000 		.word	.LC14
 1676 0f48 00000000 		.word	CyFxUSBStringLangIDDscr
 1677 0f4c F4020000 		.word	.LC15
 1678 0f50 00000000 		.word	CyFxUSBManufactureDscr
 1679 0f54 00000000 		.word	CyFxUSBProductDscr
 1680 0f58 00000000 		.word	gl_UsbLogBuffer
 1681 0f5c 28030000 		.word	.LC16
 1682 0f60 48030000 		.word	.LC17
 1683 0f64 00000000 		.word	glIsApplnActive
 1684 0f68 70030000 		.word	.LC18
 1685              		.cfi_endproc
 1686              	.LFE8:
 1688              		.section	.rodata
 1689              		.align	2
 1690              	.LC19:
 1691 0394 0A0A6465 		.ascii	"\012\012debug initialized\015\012\000"
 1691      62756720 
 1691      696E6974 
 1691      69616C69 
 1691      7A65640D 
 1692 03aa 0000     		.align	2
 1693              	.LC20:
 1694 03ac 52656D6F 		.ascii	"Remote wake attempt failed with code: %d\015\012\000"
 1694      74652077 
 1694      616B6520 
 1694      61747465 
 1694      6D707420 
 1695 03d7 00       		.align	2
 1696              	.LC21:
 1697 03d8 456E7465 		.ascii	"Enter standby returned %d\015\012\000"
 1697      72207374 
 1697      616E6462 
 1697      79207265 
 1697      7475726E 
 1698              		.align	2
 1699              	.LC22:
 1700 03f4 55534220 		.ascii	"USB LOG: %x\015\012\000"
 1700      4C4F473A 
 1700      2025780D 
 1700      0A00
 1701              		.text
 1702              		.align	2
 1703              		.global	BulkSrcSinkAppThread_Entry
 1705              	BulkSrcSinkAppThread_Entry:
 1706              	.LFB9:
 745:../cyfxbulksrcsink.c **** 
 746:../cyfxbulksrcsink.c **** /* Entry function for the BulkSrcSinkAppThread. */
 747:../cyfxbulksrcsink.c **** void
 748:../cyfxbulksrcsink.c **** BulkSrcSinkAppThread_Entry (
 749:../cyfxbulksrcsink.c ****         uint32_t input)
 750:../cyfxbulksrcsink.c **** {
 1707              		.loc 1 750 0
 1708              		.cfi_startproc
 1709              		@ args = 0, pretend = 0, frame = 56
 1710              		@ frame_needed = 1, uses_anonymous_args = 0
 1711 0f6c 00482DE9 		stmfd	sp!, {fp, lr}
 1712              	.LCFI18:
 1713              		.cfi_def_cfa_offset 8
 1714 0f70 04B08DE2 		add	fp, sp, #4
 1715              		.cfi_offset 14, -4
 1716              		.cfi_offset 11, -8
 1717              	.LCFI19:
 1718              		.cfi_def_cfa 11, 4
 1719 0f74 40D04DE2 		sub	sp, sp, #64
 1720 0f78 38000BE5 		str	r0, [fp, #-56]
 751:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t stat;
 752:../cyfxbulksrcsink.c ****     uint32_t eventMask = CYFX_USB_CTRL_TASK | CYFX_USB_HOSTWAKE_TASK;   /* Mask representing events
 1721              		.loc 1 752 0
 1722 0f7c 0330A0E3 		mov	r3, #3
 1723 0f80 10300BE5 		str	r3, [fp, #-16]
 753:../cyfxbulksrcsink.c ****     uint32_t eventStat;                                                 /* Variable to hold current
 754:../cyfxbulksrcsink.c **** 
 755:../cyfxbulksrcsink.c ****     uint16_t prevUsbLogIndex = 0, tmp1, tmp2;
 1724              		.loc 1 755 0
 1725 0f84 0030A0E3 		mov	r3, #0
 1726 0f88 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 756:../cyfxbulksrcsink.c ****     CyU3PUsbLinkPowerMode curState;
 757:../cyfxbulksrcsink.c **** 
 758:../cyfxbulksrcsink.c ****     /* Initialize the debug module */
 759:../cyfxbulksrcsink.c ****     CyFxBulkSrcSinkApplnDebugInit();
 1727              		.loc 1 759 0
 1728 0f8c FEFFFFEB 		bl	CyFxBulkSrcSinkApplnDebugInit
 760:../cyfxbulksrcsink.c ****     CyU3PDebugPrint (1, "\n\ndebug initialized\r\n");
 1729              		.loc 1 760 0
 1730 0f90 0100A0E3 		mov	r0, #1
 1731 0f94 24179FE5 		ldr	r1, .L136
 1732 0f98 FEFFFFEB 		bl	CyU3PDebugPrint
 761:../cyfxbulksrcsink.c **** 
 762:../cyfxbulksrcsink.c ****     /* Initialize the application */
 763:../cyfxbulksrcsink.c ****     CyFxBulkSrcSinkApplnInit();
 1733              		.loc 1 763 0
 1734 0f9c FEFFFFEB 		bl	CyFxBulkSrcSinkApplnInit
 1735              	.L135:
 764:../cyfxbulksrcsink.c **** 
 765:../cyfxbulksrcsink.c ****     for (;;)
 766:../cyfxbulksrcsink.c ****     {
 767:../cyfxbulksrcsink.c ****         /* The following call will block until at least one of the events enabled in eventMask is r
 768:../cyfxbulksrcsink.c ****            The eventStat variable will hold the events that were active at the time of returning fr
 769:../cyfxbulksrcsink.c ****            The CLEAR flag means that all events will be atomically cleared before this function ret
 770:../cyfxbulksrcsink.c ****           
 771:../cyfxbulksrcsink.c ****            We cause this event wait to time out every 10 milli-seconds, so that we can periodically
 772:../cyfxbulksrcsink.c ****            device out of low power modes.
 773:../cyfxbulksrcsink.c ****          */
 774:../cyfxbulksrcsink.c ****         stat = CyU3PEventGet (&glBulkLpEvent, eventMask, CYU3P_EVENT_OR_CLEAR, &eventStat, 10);
 1736              		.loc 1 774 0
 1737 0fa0 24304BE2 		sub	r3, fp, #36
 1738 0fa4 0A20A0E3 		mov	r2, #10
 1739 0fa8 00208DE5 		str	r2, [sp, #0]
 1740 0fac 10079FE5 		ldr	r0, .L136+4
 1741 0fb0 10101BE5 		ldr	r1, [fp, #-16]
 1742 0fb4 0120A0E3 		mov	r2, #1
 1743 0fb8 FEFFFFEB 		bl	_txe_event_flags_get
 1744 0fbc 08000BE5 		str	r0, [fp, #-8]
 775:../cyfxbulksrcsink.c ****         if (stat == CY_U3P_SUCCESS)
 1745              		.loc 1 775 0
 1746 0fc0 08301BE5 		ldr	r3, [fp, #-8]
 1747 0fc4 000053E3 		cmp	r3, #0
 1748 0fc8 3D01001A 		bne	.L96
 776:../cyfxbulksrcsink.c ****         {
 777:../cyfxbulksrcsink.c ****             /* If the HOSTWAKE task is set, send a DEV_NOTIFICATION (FUNCTION_WAKE) or remote wakeu
 778:../cyfxbulksrcsink.c ****                based on the USB connection speed. */
 779:../cyfxbulksrcsink.c ****             if (eventStat & CYFX_USB_HOSTWAKE_TASK)
 1749              		.loc 1 779 0
 1750 0fcc 24301BE5 		ldr	r3, [fp, #-36]
 1751 0fd0 023003E2 		and	r3, r3, #2
 1752 0fd4 000053E3 		cmp	r3, #0
 1753 0fd8 1400000A 		beq	.L97
 780:../cyfxbulksrcsink.c ****             {
 781:../cyfxbulksrcsink.c ****                 CyU3PThreadSleep (1000);
 1754              		.loc 1 781 0
 1755 0fdc FA0FA0E3 		mov	r0, #1000
 1756 0fe0 FEFFFFEB 		bl	_tx_thread_sleep
 782:../cyfxbulksrcsink.c ****                 if (CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED)
 1757              		.loc 1 782 0
 1758 0fe4 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 1759 0fe8 0030A0E1 		mov	r3, r0
 1760 0fec 030053E3 		cmp	r3, #3
 1761 0ff0 0500001A 		bne	.L98
 783:../cyfxbulksrcsink.c ****                     stat = CyU3PUsbSendDevNotification (1, 0, 0);
 1762              		.loc 1 783 0
 1763 0ff4 0100A0E3 		mov	r0, #1
 1764 0ff8 0010A0E3 		mov	r1, #0
 1765 0ffc 0020A0E3 		mov	r2, #0
 1766 1000 FEFFFFEB 		bl	CyU3PUsbSendDevNotification
 1767 1004 08000BE5 		str	r0, [fp, #-8]
 1768 1008 010000EA 		b	.L99
 1769              	.L98:
 784:../cyfxbulksrcsink.c ****                 else
 785:../cyfxbulksrcsink.c ****                     stat = CyU3PUsbDoRemoteWakeup ();
 1770              		.loc 1 785 0
 1771 100c FEFFFFEB 		bl	CyU3PUsbDoRemoteWakeup
 1772 1010 08000BE5 		str	r0, [fp, #-8]
 1773              	.L99:
 786:../cyfxbulksrcsink.c **** 
 787:../cyfxbulksrcsink.c ****                 if (stat != CY_U3P_SUCCESS)
 1774              		.loc 1 787 0
 1775 1014 08301BE5 		ldr	r3, [fp, #-8]
 1776 1018 000053E3 		cmp	r3, #0
 1777 101c 0300000A 		beq	.L97
 788:../cyfxbulksrcsink.c ****                     CyU3PDebugPrint (2, "Remote wake attempt failed with code: %d\r\n", stat);
 1778              		.loc 1 788 0
 1779 1020 0200A0E3 		mov	r0, #2
 1780 1024 9C169FE5 		ldr	r1, .L136+8
 1781 1028 08201BE5 		ldr	r2, [fp, #-8]
 1782 102c FEFFFFEB 		bl	CyU3PDebugPrint
 1783              	.L97:
 789:../cyfxbulksrcsink.c ****             }
 790:../cyfxbulksrcsink.c **** 
 791:../cyfxbulksrcsink.c ****             /* If there is a pending control request, handle it here. */
 792:../cyfxbulksrcsink.c ****             if (eventStat & CYFX_USB_CTRL_TASK)
 1784              		.loc 1 792 0
 1785 1030 24301BE5 		ldr	r3, [fp, #-36]
 1786 1034 013003E2 		and	r3, r3, #1
 1787 1038 FF3003E2 		and	r3, r3, #255
 1788 103c 000053E3 		cmp	r3, #0
 1789 1040 1F01000A 		beq	.L96
 1790              	.LBB3:
 793:../cyfxbulksrcsink.c ****             {
 794:../cyfxbulksrcsink.c ****                 uint8_t  bRequest, bReqType;
 795:../cyfxbulksrcsink.c ****                 uint16_t wLength, temp;
 796:../cyfxbulksrcsink.c ****                 uint16_t wValue, wIndex;
 797:../cyfxbulksrcsink.c **** 
 798:../cyfxbulksrcsink.c ****                 /* Decode the fields from the setup request. */
 799:../cyfxbulksrcsink.c ****                 bReqType = (gl_setupdat0 & CY_U3P_USB_REQUEST_TYPE_MASK);
 1791              		.loc 1 799 0
 1792 1044 80369FE5 		ldr	r3, .L136+12
 1793 1048 003093E5 		ldr	r3, [r3, #0]
 1794 104c 11304BE5 		strb	r3, [fp, #-17]
 800:../cyfxbulksrcsink.c ****                 bRequest = ((gl_setupdat0 & CY_U3P_USB_REQUEST_MASK) >> CY_U3P_USB_REQUEST_POS);
 1795              		.loc 1 800 0
 1796 1050 74369FE5 		ldr	r3, .L136+12
 1797 1054 003093E5 		ldr	r3, [r3, #0]
 1798 1058 FF3C03E2 		and	r3, r3, #65280
 1799 105c 2334A0E1 		mov	r3, r3, lsr #8
 1800 1060 12304BE5 		strb	r3, [fp, #-18]
 801:../cyfxbulksrcsink.c ****                 wLength  = ((gl_setupdat1 & CY_U3P_USB_LENGTH_MASK)  >> CY_U3P_USB_LENGTH_POS);
 1801              		.loc 1 801 0
 1802 1064 64369FE5 		ldr	r3, .L136+16
 1803 1068 003093E5 		ldr	r3, [r3, #0]
 1804 106c 2338A0E1 		mov	r3, r3, lsr #16
 1805 1070 0338A0E1 		mov	r3, r3, asl #16
 1806 1074 2338A0E1 		mov	r3, r3, lsr #16
 1807 1078 B8324BE1 		strh	r3, [fp, #-40]	@ movhi
 802:../cyfxbulksrcsink.c ****                 wValue   = ((gl_setupdat0 & CY_U3P_USB_VALUE_MASK) >> CY_U3P_USB_VALUE_POS);
 1808              		.loc 1 802 0
 1809 107c 48369FE5 		ldr	r3, .L136+12
 1810 1080 003093E5 		ldr	r3, [r3, #0]
 1811 1084 2338A0E1 		mov	r3, r3, lsr #16
 1812 1088 B4314BE1 		strh	r3, [fp, #-20]	@ movhi
 803:../cyfxbulksrcsink.c ****                 wIndex   = ((gl_setupdat1 & CY_U3P_USB_INDEX_MASK) >> CY_U3P_USB_INDEX_POS);
 1813              		.loc 1 803 0
 1814 108c 3C369FE5 		ldr	r3, .L136+16
 1815 1090 003093E5 		ldr	r3, [r3, #0]
 1816 1094 B6314BE1 		strh	r3, [fp, #-22]	@ movhi
 804:../cyfxbulksrcsink.c **** 
 805:../cyfxbulksrcsink.c ****                 if ((bReqType & CY_U3P_USB_TYPE_MASK) == CY_U3P_USB_VENDOR_RQT)
 1817              		.loc 1 805 0
 1818 1098 11305BE5 		ldrb	r3, [fp, #-17]	@ zero_extendqisi2
 1819 109c 603003E2 		and	r3, r3, #96
 1820 10a0 400053E3 		cmp	r3, #64
 1821 10a4 0201001A 		bne	.L100
 806:../cyfxbulksrcsink.c ****                 {
 807:../cyfxbulksrcsink.c ****                     switch (bRequest)
 1822              		.loc 1 807 0
 1823 10a8 12305BE5 		ldrb	r3, [fp, #-18]	@ zero_extendqisi2
 1824 10ac 773043E2 		sub	r3, r3, #119
 1825 10b0 6A0053E3 		cmp	r3, #106
 1826 10b4 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 1827 10b8 F80000EA 		b	.L101
 1828              	.L113:
 1829 10bc 68120000 		.word	.L102
 1830 10c0 80120000 		.word	.L103
 1831 10c4 A4120000 		.word	.L104
 1832 10c8 A0140000 		.word	.L101
 1833 10cc A0140000 		.word	.L101
 1834 10d0 A0140000 		.word	.L101
 1835 10d4 A0140000 		.word	.L101
 1836 10d8 A0140000 		.word	.L101
 1837 10dc A0140000 		.word	.L101
 1838 10e0 B4120000 		.word	.L105
 1839 10e4 CC120000 		.word	.L106
 1840 10e8 1C130000 		.word	.L107
 1841 10ec 74130000 		.word	.L108
 1842 10f0 B0130000 		.word	.L109
 1843 10f4 A0140000 		.word	.L101
 1844 10f8 A0140000 		.word	.L101
 1845 10fc A0140000 		.word	.L101
 1846 1100 A0140000 		.word	.L101
 1847 1104 A0140000 		.word	.L101
 1848 1108 A0140000 		.word	.L101
 1849 110c A0140000 		.word	.L101
 1850 1110 A0140000 		.word	.L101
 1851 1114 A0140000 		.word	.L101
 1852 1118 A0140000 		.word	.L101
 1853 111c A0140000 		.word	.L101
 1854 1120 20140000 		.word	.L110
 1855 1124 A0140000 		.word	.L101
 1856 1128 A0140000 		.word	.L101
 1857 112c A0140000 		.word	.L101
 1858 1130 A0140000 		.word	.L101
 1859 1134 A0140000 		.word	.L101
 1860 1138 A0140000 		.word	.L101
 1861 113c A0140000 		.word	.L101
 1862 1140 A0140000 		.word	.L101
 1863 1144 A0140000 		.word	.L101
 1864 1148 A0140000 		.word	.L101
 1865 114c A0140000 		.word	.L101
 1866 1150 A0140000 		.word	.L101
 1867 1154 A0140000 		.word	.L101
 1868 1158 A0140000 		.word	.L101
 1869 115c A0140000 		.word	.L101
 1870 1160 A0140000 		.word	.L101
 1871 1164 A0140000 		.word	.L101
 1872 1168 A0140000 		.word	.L101
 1873 116c A0140000 		.word	.L101
 1874 1170 A0140000 		.word	.L101
 1875 1174 A0140000 		.word	.L101
 1876 1178 A0140000 		.word	.L101
 1877 117c A0140000 		.word	.L101
 1878 1180 A0140000 		.word	.L101
 1879 1184 A0140000 		.word	.L101
 1880 1188 A0140000 		.word	.L101
 1881 118c A0140000 		.word	.L101
 1882 1190 A0140000 		.word	.L101
 1883 1194 A0140000 		.word	.L101
 1884 1198 A0140000 		.word	.L101
 1885 119c A0140000 		.word	.L101
 1886 11a0 A0140000 		.word	.L101
 1887 11a4 A0140000 		.word	.L101
 1888 11a8 A0140000 		.word	.L101
 1889 11ac A0140000 		.word	.L101
 1890 11b0 A0140000 		.word	.L101
 1891 11b4 A0140000 		.word	.L101
 1892 11b8 A0140000 		.word	.L101
 1893 11bc A0140000 		.word	.L101
 1894 11c0 A0140000 		.word	.L101
 1895 11c4 A0140000 		.word	.L101
 1896 11c8 A0140000 		.word	.L101
 1897 11cc A0140000 		.word	.L101
 1898 11d0 A0140000 		.word	.L101
 1899 11d4 A0140000 		.word	.L101
 1900 11d8 A0140000 		.word	.L101
 1901 11dc A0140000 		.word	.L101
 1902 11e0 A0140000 		.word	.L101
 1903 11e4 A0140000 		.word	.L101
 1904 11e8 A0140000 		.word	.L101
 1905 11ec A0140000 		.word	.L101
 1906 11f0 A0140000 		.word	.L101
 1907 11f4 A0140000 		.word	.L101
 1908 11f8 A0140000 		.word	.L101
 1909 11fc A0140000 		.word	.L101
 1910 1200 A0140000 		.word	.L101
 1911 1204 A0140000 		.word	.L101
 1912 1208 A0140000 		.word	.L101
 1913 120c A0140000 		.word	.L101
 1914 1210 A0140000 		.word	.L101
 1915 1214 A0140000 		.word	.L101
 1916 1218 A0140000 		.word	.L101
 1917 121c A0140000 		.word	.L101
 1918 1220 A0140000 		.word	.L101
 1919 1224 A0140000 		.word	.L101
 1920 1228 A0140000 		.word	.L101
 1921 122c A0140000 		.word	.L101
 1922 1230 A0140000 		.word	.L101
 1923 1234 A0140000 		.word	.L101
 1924 1238 A0140000 		.word	.L101
 1925 123c A0140000 		.word	.L101
 1926 1240 A0140000 		.word	.L101
 1927 1244 A0140000 		.word	.L101
 1928 1248 A0140000 		.word	.L101
 1929 124c A0140000 		.word	.L101
 1930 1250 A0140000 		.word	.L101
 1931 1254 A0140000 		.word	.L101
 1932 1258 A0140000 		.word	.L101
 1933 125c A0140000 		.word	.L101
 1934 1260 54140000 		.word	.L111
 1935 1264 88140000 		.word	.L112
 1936              	.L102:
 808:../cyfxbulksrcsink.c ****                     {
 809:../cyfxbulksrcsink.c ****                     case 0x77:      /* Trigger remote wakeup. */
 810:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 1937              		.loc 1 810 0
 1938 1268 FEFFFFEB 		bl	CyU3PUsbAckSetup
 811:../cyfxbulksrcsink.c ****                         CyU3PEventSet (&glBulkLpEvent, CYFX_USB_HOSTWAKE_TASK, CYU3P_EVENT_OR);
 1939              		.loc 1 811 0
 1940 126c 50049FE5 		ldr	r0, .L136+4
 1941 1270 0210A0E3 		mov	r1, #2
 1942 1274 0020A0E3 		mov	r2, #0
 1943 1278 FEFFFFEB 		bl	_txe_event_flags_set
 812:../cyfxbulksrcsink.c ****                         break;
 1944              		.loc 1 812 0
 1945 127c 900000EA 		b	.L96
 1946              	.L103:
 813:../cyfxbulksrcsink.c **** 
 814:../cyfxbulksrcsink.c ****                     case 0x78:      /* Get count of EP0 status events received. */
 815:../cyfxbulksrcsink.c ****                         CyU3PMemCopy ((uint8_t *)glEp0Buffer, ((uint8_t *)&glEp0StatCount), 4);
 1947              		.loc 1 815 0
 1948 1280 4C349FE5 		ldr	r3, .L136+20
 1949 1284 4C049FE5 		ldr	r0, .L136+24
 1950 1288 0310A0E1 		mov	r1, r3
 1951 128c 0420A0E3 		mov	r2, #4
 1952 1290 FEFFFFEB 		bl	CyU3PMemCopy
 816:../cyfxbulksrcsink.c ****                         CyU3PUsbSendEP0Data (4, glEp0Buffer);
 1953              		.loc 1 816 0
 1954 1294 0400A0E3 		mov	r0, #4
 1955 1298 38149FE5 		ldr	r1, .L136+24
 1956 129c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 817:../cyfxbulksrcsink.c ****                         break;
 1957              		.loc 1 817 0
 1958 12a0 870000EA 		b	.L96
 1959              	.L104:
 818:../cyfxbulksrcsink.c **** 
 819:../cyfxbulksrcsink.c ****                     case 0x79:      /* Request with no data phase. Insert a delay and then ACK the 
 820:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (5);
 1960              		.loc 1 820 0
 1961 12a4 0500A0E3 		mov	r0, #5
 1962 12a8 FEFFFFEB 		bl	_tx_thread_sleep
 821:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 1963              		.loc 1 821 0
 1964 12ac FEFFFFEB 		bl	CyU3PUsbAckSetup
 822:../cyfxbulksrcsink.c ****                         break;
 1965              		.loc 1 822 0
 1966 12b0 830000EA 		b	.L96
 1967              	.L105:
 823:../cyfxbulksrcsink.c **** 
 824:../cyfxbulksrcsink.c ****                     case 0x80:      /* Request with OUT data phase. Just get the data and ignore it
 825:../cyfxbulksrcsink.c ****                         CyU3PUsbGetEP0Data (sizeof (glEp0Buffer), (uint8_t *)glEp0Buffer, &wLength)
 1968              		.loc 1 825 0
 1969 12b4 28304BE2 		sub	r3, fp, #40
 1970 12b8 2000A0E3 		mov	r0, #32
 1971 12bc 14149FE5 		ldr	r1, .L136+24
 1972 12c0 0320A0E1 		mov	r2, r3
 1973 12c4 FEFFFFEB 		bl	CyU3PUsbGetEP0Data
 826:../cyfxbulksrcsink.c ****                         break;
 1974              		.loc 1 826 0
 1975 12c8 7D0000EA 		b	.L96
 1976              	.L106:
 827:../cyfxbulksrcsink.c **** 
 828:../cyfxbulksrcsink.c ****                     case 0x81:
 829:../cyfxbulksrcsink.c ****                         /* Get the current event log index and send it to the host. */
 830:../cyfxbulksrcsink.c ****                         if (wLength == 2)
 1977              		.loc 1 830 0
 1978 12cc B8325BE1 		ldrh	r3, [fp, #-40]
 1979 12d0 020053E3 		cmp	r3, #2
 1980 12d4 0B00001A 		bne	.L115
 831:../cyfxbulksrcsink.c ****                         {
 832:../cyfxbulksrcsink.c ****                             temp = CyU3PUsbGetEventLogIndex ();
 1981              		.loc 1 832 0
 1982 12d8 FEFFFFEB 		bl	CyU3PUsbGetEventLogIndex
 1983 12dc 0030A0E1 		mov	r3, r0
 1984 12e0 BA324BE1 		strh	r3, [fp, #-42]	@ movhi
 833:../cyfxbulksrcsink.c ****                             CyU3PMemCopy ((uint8_t *)glEp0Buffer, (uint8_t *)&temp, 2);
 1985              		.loc 1 833 0
 1986 12e4 2A304BE2 		sub	r3, fp, #42
 1987 12e8 E8039FE5 		ldr	r0, .L136+24
 1988 12ec 0310A0E1 		mov	r1, r3
 1989 12f0 0220A0E3 		mov	r2, #2
 1990 12f4 FEFFFFEB 		bl	CyU3PMemCopy
 834:../cyfxbulksrcsink.c ****                             CyU3PUsbSendEP0Data (2, glEp0Buffer);
 1991              		.loc 1 834 0
 1992 12f8 0200A0E3 		mov	r0, #2
 1993 12fc D4139FE5 		ldr	r1, .L136+24
 1994 1300 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 835:../cyfxbulksrcsink.c ****                         }
 836:../cyfxbulksrcsink.c ****                         else
 837:../cyfxbulksrcsink.c ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 838:../cyfxbulksrcsink.c ****                         break;
 1995              		.loc 1 838 0
 1996 1304 6E0000EA 		b	.L96
 1997              	.L115:
 837:../cyfxbulksrcsink.c ****                             CyU3PUsbStall (0, CyTrue, CyFalse);
 1998              		.loc 1 837 0
 1999 1308 0000A0E3 		mov	r0, #0
 2000 130c 0110A0E3 		mov	r1, #1
 2001 1310 0020A0E3 		mov	r2, #0
 2002 1314 FEFFFFEB 		bl	CyU3PUsbStall
 2003              		.loc 1 838 0
 2004 1318 690000EA 		b	.L96
 2005              	.L107:
 839:../cyfxbulksrcsink.c **** 
 840:../cyfxbulksrcsink.c ****                     case 0x82:
 841:../cyfxbulksrcsink.c ****                         /* Send the USB event log buffer content to the host. */
 842:../cyfxbulksrcsink.c ****                         if (wLength != 0)
 2006              		.loc 1 842 0
 2007 131c B8325BE1 		ldrh	r3, [fp, #-40]
 2008 1320 000053E3 		cmp	r3, #0
 2009 1324 1000000A 		beq	.L117
 843:../cyfxbulksrcsink.c ****                         {
 844:../cyfxbulksrcsink.c ****                             if (wLength < CYFX_USBLOG_SIZE)
 2010              		.loc 1 844 0
 2011 1328 B8225BE1 		ldrh	r2, [fp, #-40]
 2012 132c A8339FE5 		ldr	r3, .L136+28
 2013 1330 030052E1 		cmp	r2, r3
 2014 1334 0600008A 		bhi	.L118
 845:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (wLength, gl_UsbLogBuffer);
 2015              		.loc 1 845 0
 2016 1338 B8225BE1 		ldrh	r2, [fp, #-40]
 2017 133c 9C339FE5 		ldr	r3, .L136+32
 2018 1340 003093E5 		ldr	r3, [r3, #0]
 2019 1344 0200A0E1 		mov	r0, r2
 2020 1348 0310A0E1 		mov	r1, r3
 2021 134c FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 846:../cyfxbulksrcsink.c ****                             else
 847:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (CYFX_USBLOG_SIZE, gl_UsbLogBuffer);
 848:../cyfxbulksrcsink.c ****                         }
 849:../cyfxbulksrcsink.c ****                         else
 850:../cyfxbulksrcsink.c ****                             CyU3PUsbAckSetup ();
 851:../cyfxbulksrcsink.c ****                         break;
 2022              		.loc 1 851 0
 2023 1350 5B0000EA 		b	.L96
 2024              	.L118:
 847:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (CYFX_USBLOG_SIZE, gl_UsbLogBuffer);
 2025              		.loc 1 847 0
 2026 1354 84339FE5 		ldr	r3, .L136+32
 2027 1358 003093E5 		ldr	r3, [r3, #0]
 2028 135c 010AA0E3 		mov	r0, #4096
 2029 1360 0310A0E1 		mov	r1, r3
 2030 1364 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2031              		.loc 1 851 0
 2032 1368 550000EA 		b	.L96
 2033              	.L117:
 850:../cyfxbulksrcsink.c ****                             CyU3PUsbAckSetup ();
 2034              		.loc 1 850 0
 2035 136c FEFFFFEB 		bl	CyU3PUsbAckSetup
 2036              		.loc 1 851 0
 2037 1370 530000EA 		b	.L96
 2038              	.L108:
 2039              	.LBB4:
 852:../cyfxbulksrcsink.c **** 
 853:../cyfxbulksrcsink.c ****                     case 0x83:
 854:../cyfxbulksrcsink.c ****                         {
 855:../cyfxbulksrcsink.c ****                             uint32_t addr = ((uint32_t)wValue << 16) | (uint32_t)wIndex;
 2040              		.loc 1 855 0
 2041 1374 B4315BE1 		ldrh	r3, [fp, #-20]
 2042 1378 0328A0E1 		mov	r2, r3, asl #16
 2043 137c B6315BE1 		ldrh	r3, [fp, #-22]
 2044 1380 033082E1 		orr	r3, r2, r3
 2045 1384 1C300BE5 		str	r3, [fp, #-28]
 856:../cyfxbulksrcsink.c ****                             CyU3PReadDeviceRegisters ((uvint32_t *)addr, 1, (uint32_t *)glEp0Buffer
 2046              		.loc 1 856 0
 2047 1388 1C201BE5 		ldr	r2, [fp, #-28]
 2048 138c 44339FE5 		ldr	r3, .L136+24
 2049 1390 0200A0E1 		mov	r0, r2
 2050 1394 0110A0E3 		mov	r1, #1
 2051 1398 0320A0E1 		mov	r2, r3
 2052 139c FEFFFFEB 		bl	CyU3PReadDeviceRegisters
 857:../cyfxbulksrcsink.c ****                             CyU3PUsbSendEP0Data (4, glEp0Buffer);
 2053              		.loc 1 857 0
 2054 13a0 0400A0E3 		mov	r0, #4
 2055 13a4 2C139FE5 		ldr	r1, .L136+24
 2056 13a8 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2057              	.LBE4:
 858:../cyfxbulksrcsink.c ****                         }
 859:../cyfxbulksrcsink.c ****                         break;
 2058              		.loc 1 859 0
 2059 13ac 440000EA 		b	.L96
 2060              	.L109:
 2061              	.LBB5:
 860:../cyfxbulksrcsink.c **** 
 861:../cyfxbulksrcsink.c ****                     case 0x84:
 862:../cyfxbulksrcsink.c ****                         {
 863:../cyfxbulksrcsink.c ****                             uint8_t major, minor, patch;
 864:../cyfxbulksrcsink.c **** 
 865:../cyfxbulksrcsink.c ****                             if (CyU3PUsbGetBooterVersion (&major, &minor, &patch) == CY_U3P_SUCCESS
 2062              		.loc 1 865 0
 2063 13b0 2B104BE2 		sub	r1, fp, #43
 2064 13b4 2C204BE2 		sub	r2, fp, #44
 2065 13b8 2D304BE2 		sub	r3, fp, #45
 2066 13bc 0100A0E1 		mov	r0, r1
 2067 13c0 0210A0E1 		mov	r1, r2
 2068 13c4 0320A0E1 		mov	r2, r3
 2069 13c8 FEFFFFEB 		bl	CyU3PUsbGetBooterVersion
 2070 13cc 0030A0E1 		mov	r3, r0
 2071 13d0 000053E3 		cmp	r3, #0
 2072 13d4 0C00001A 		bne	.L120
 866:../cyfxbulksrcsink.c ****                             {
 867:../cyfxbulksrcsink.c ****                                 glEp0Buffer[0] = major;
 2073              		.loc 1 867 0
 2074 13d8 2B205BE5 		ldrb	r2, [fp, #-43]	@ zero_extendqisi2
 2075 13dc F4329FE5 		ldr	r3, .L136+24
 2076 13e0 0020C3E5 		strb	r2, [r3, #0]
 868:../cyfxbulksrcsink.c ****                                 glEp0Buffer[1] = minor;
 2077              		.loc 1 868 0
 2078 13e4 2C205BE5 		ldrb	r2, [fp, #-44]	@ zero_extendqisi2
 2079 13e8 E8329FE5 		ldr	r3, .L136+24
 2080 13ec 0120C3E5 		strb	r2, [r3, #1]
 869:../cyfxbulksrcsink.c ****                                 glEp0Buffer[2] = patch;
 2081              		.loc 1 869 0
 2082 13f0 2D205BE5 		ldrb	r2, [fp, #-45]	@ zero_extendqisi2
 2083 13f4 DC329FE5 		ldr	r3, .L136+24
 2084 13f8 0220C3E5 		strb	r2, [r3, #2]
 870:../cyfxbulksrcsink.c ****                                 CyU3PUsbSendEP0Data (3, glEp0Buffer);
 2085              		.loc 1 870 0
 2086 13fc 0300A0E3 		mov	r0, #3
 2087 1400 D0129FE5 		ldr	r1, .L136+24
 2088 1404 FEFFFFEB 		bl	CyU3PUsbSendEP0Data
 2089              	.LBE5:
 871:../cyfxbulksrcsink.c ****                             }
 872:../cyfxbulksrcsink.c ****                             else
 873:../cyfxbulksrcsink.c ****                                 CyU3PUsbStall (0, CyTrue, CyFalse);
 874:../cyfxbulksrcsink.c ****                         }
 875:../cyfxbulksrcsink.c ****                         break;
 2090              		.loc 1 875 0
 2091 1408 2D0000EA 		b	.L96
 2092              	.L120:
 2093              	.LBB6:
 873:../cyfxbulksrcsink.c ****                                 CyU3PUsbStall (0, CyTrue, CyFalse);
 2094              		.loc 1 873 0
 2095 140c 0000A0E3 		mov	r0, #0
 2096 1410 0110A0E3 		mov	r1, #1
 2097 1414 0020A0E3 		mov	r2, #0
 2098 1418 FEFFFFEB 		bl	CyU3PUsbStall
 2099              	.LBE6:
 2100              		.loc 1 875 0
 2101 141c 280000EA 		b	.L96
 2102              	.L110:
 876:../cyfxbulksrcsink.c **** 
 877:../cyfxbulksrcsink.c ****                     case 0x90:
 878:../cyfxbulksrcsink.c ****                         /* Request to switch control back to the boot firmware. */
 879:../cyfxbulksrcsink.c **** 
 880:../cyfxbulksrcsink.c ****                         /* Complete the control request. */
 881:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 2103              		.loc 1 881 0
 2104 1420 FEFFFFEB 		bl	CyU3PUsbAckSetup
 882:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (10);
 2105              		.loc 1 882 0
 2106 1424 0A00A0E3 		mov	r0, #10
 2107 1428 FEFFFFEB 		bl	_tx_thread_sleep
 883:../cyfxbulksrcsink.c **** 
 884:../cyfxbulksrcsink.c ****                         /* Get rid of the DMA channels and EP configuration. */
 885:../cyfxbulksrcsink.c ****                         CyFxBulkSrcSinkApplnStop ();
 2108              		.loc 1 885 0
 2109 142c FEFFFFEB 		bl	CyFxBulkSrcSinkApplnStop
 886:../cyfxbulksrcsink.c **** 
 887:../cyfxbulksrcsink.c ****                         /* De-initialize the Debug and UART modules. */
 888:../cyfxbulksrcsink.c ****                         CyU3PDebugDeInit ();
 2110              		.loc 1 888 0
 2111 1430 FEFFFFEB 		bl	CyU3PDebugDeInit
 889:../cyfxbulksrcsink.c ****                         CyU3PUartDeInit ();
 2112              		.loc 1 889 0
 2113 1434 FEFFFFEB 		bl	CyU3PUartDeInit
 890:../cyfxbulksrcsink.c **** 
 891:../cyfxbulksrcsink.c ****                         /* Now jump back to the boot firmware image. */
 892:../cyfxbulksrcsink.c ****                         CyU3PUsbSetBooterSwitch (CyTrue);
 2114              		.loc 1 892 0
 2115 1438 0100A0E3 		mov	r0, #1
 2116 143c FEFFFFEB 		bl	CyU3PUsbSetBooterSwitch
 893:../cyfxbulksrcsink.c ****                         CyU3PUsbJumpBackToBooter (0x40078000);
 2117              		.loc 1 893 0
 2118 1440 9C029FE5 		ldr	r0, .L136+36
 2119 1444 FEFFFFEB 		bl	CyU3PUsbJumpBackToBooter
 2120              	.L122:
 894:../cyfxbulksrcsink.c ****                         while (1)
 895:../cyfxbulksrcsink.c ****                             CyU3PThreadSleep (100);
 2121              		.loc 1 895 0 discriminator 1
 2122 1448 6400A0E3 		mov	r0, #100
 2123 144c FEFFFFEB 		bl	_tx_thread_sleep
 2124 1450 FCFFFFEA 		b	.L122
 2125              	.L111:
 896:../cyfxbulksrcsink.c ****                         break;
 897:../cyfxbulksrcsink.c **** 
 898:../cyfxbulksrcsink.c ****                     case 0xE0:
 899:../cyfxbulksrcsink.c ****                         /* Request to reset the FX3 device. */
 900:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 2126              		.loc 1 900 0
 2127 1454 FEFFFFEB 		bl	CyU3PUsbAckSetup
 901:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (2000);
 2128              		.loc 1 901 0
 2129 1458 7D0EA0E3 		mov	r0, #2000
 2130 145c FEFFFFEB 		bl	_tx_thread_sleep
 902:../cyfxbulksrcsink.c ****                         CyU3PConnectState (CyFalse, CyTrue);
 2131              		.loc 1 902 0
 2132 1460 0000A0E3 		mov	r0, #0
 2133 1464 0110A0E3 		mov	r1, #1
 2134 1468 FEFFFFEB 		bl	CyU3PConnectState
 903:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (1000);
 2135              		.loc 1 903 0
 2136 146c FA0FA0E3 		mov	r0, #1000
 2137 1470 FEFFFFEB 		bl	_tx_thread_sleep
 904:../cyfxbulksrcsink.c ****                         CyU3PDeviceReset (CyFalse);
 2138              		.loc 1 904 0
 2139 1474 0000A0E3 		mov	r0, #0
 2140 1478 FEFFFFEB 		bl	CyU3PDeviceReset
 905:../cyfxbulksrcsink.c ****                         CyU3PThreadSleep (1000);
 2141              		.loc 1 905 0
 2142 147c FA0FA0E3 		mov	r0, #1000
 2143 1480 FEFFFFEB 		bl	_tx_thread_sleep
 906:../cyfxbulksrcsink.c ****                         break;
 2144              		.loc 1 906 0
 2145 1484 0E0000EA 		b	.L96
 2146              	.L112:
 907:../cyfxbulksrcsink.c **** 
 908:../cyfxbulksrcsink.c ****                     case 0xE1:
 909:../cyfxbulksrcsink.c ****                         /* Request to place FX3 in standby when VBus is next disconnected. */
 910:../cyfxbulksrcsink.c ****                         StandbyModeEnable = CyTrue;
 2147              		.loc 1 910 0
 2148 1488 58329FE5 		ldr	r3, .L136+40
 2149 148c 0120A0E3 		mov	r2, #1
 2150 1490 002083E5 		str	r2, [r3, #0]
 911:../cyfxbulksrcsink.c ****                         CyU3PUsbAckSetup ();
 2151              		.loc 1 911 0
 2152 1494 FEFFFFEB 		bl	CyU3PUsbAckSetup
 912:../cyfxbulksrcsink.c ****                         break;
 2153              		.loc 1 912 0
 2154 1498 0000A0E1 		mov	r0, r0	@ nop
 2155 149c 080000EA 		b	.L96
 2156              	.L101:
 913:../cyfxbulksrcsink.c **** 
 914:../cyfxbulksrcsink.c ****                     default:        /* Unknown request. Stall EP0. */
 915:../cyfxbulksrcsink.c ****                         CyU3PUsbStall (0, CyTrue, CyFalse);
 2157              		.loc 1 915 0
 2158 14a0 0000A0E3 		mov	r0, #0
 2159 14a4 0110A0E3 		mov	r1, #1
 2160 14a8 0020A0E3 		mov	r2, #0
 2161 14ac FEFFFFEB 		bl	CyU3PUsbStall
 916:../cyfxbulksrcsink.c ****                         break;
 2162              		.loc 1 916 0
 2163 14b0 030000EA 		b	.L96
 2164              	.L100:
 917:../cyfxbulksrcsink.c ****                     }
 918:../cyfxbulksrcsink.c ****                 }
 919:../cyfxbulksrcsink.c ****                 else
 920:../cyfxbulksrcsink.c ****                 {
 921:../cyfxbulksrcsink.c ****                     /* Only vendor requests are to be handled here. */
 922:../cyfxbulksrcsink.c ****                     CyU3PUsbStall (0, CyTrue, CyFalse);
 2165              		.loc 1 922 0
 2166 14b4 0000A0E3 		mov	r0, #0
 2167 14b8 0110A0E3 		mov	r1, #1
 2168 14bc 0020A0E3 		mov	r2, #0
 2169 14c0 FEFFFFEB 		bl	CyU3PUsbStall
 2170              	.L96:
 2171              	.LBE3:
 923:../cyfxbulksrcsink.c ****                 }
 924:../cyfxbulksrcsink.c ****             }
 925:../cyfxbulksrcsink.c ****         }
 926:../cyfxbulksrcsink.c **** 
 927:../cyfxbulksrcsink.c ****         /* Try to get the USB 3.0 link back to U0. */
 928:../cyfxbulksrcsink.c ****         if (glForceLinkU2)
 2172              		.loc 1 928 0
 2173 14c4 20329FE5 		ldr	r3, .L136+44
 2174 14c8 003093E5 		ldr	r3, [r3, #0]
 2175 14cc 000053E3 		cmp	r3, #0
 2176 14d0 1700000A 		beq	.L123
 929:../cyfxbulksrcsink.c ****         {
 930:../cyfxbulksrcsink.c ****             stat = CyU3PUsbGetLinkPowerState (&curState);
 2177              		.loc 1 930 0
 2178 14d4 25304BE2 		sub	r3, fp, #37
 2179 14d8 0300A0E1 		mov	r0, r3
 2180 14dc FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2181 14e0 08000BE5 		str	r0, [fp, #-8]
 931:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2182              		.loc 1 931 0
 2183 14e4 070000EA 		b	.L124
 2184              	.L126:
 932:../cyfxbulksrcsink.c ****             {
 933:../cyfxbulksrcsink.c ****                 /* Repeatedly try to go into U2 state.*/
 934:../cyfxbulksrcsink.c ****                 CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U2);
 2185              		.loc 1 934 0
 2186 14e8 0200A0E3 		mov	r0, #2
 2187 14ec FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 935:../cyfxbulksrcsink.c ****                 CyU3PThreadSleep (5);
 2188              		.loc 1 935 0
 2189 14f0 0500A0E3 		mov	r0, #5
 2190 14f4 FEFFFFEB 		bl	_tx_thread_sleep
 936:../cyfxbulksrcsink.c ****                 stat = CyU3PUsbGetLinkPowerState (&curState);
 2191              		.loc 1 936 0
 2192 14f8 25304BE2 		sub	r3, fp, #37
 2193 14fc 0300A0E1 		mov	r0, r3
 2194 1500 FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2195 1504 08000BE5 		str	r0, [fp, #-8]
 2196              	.L124:
 931:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2197              		.loc 1 931 0 discriminator 1
 2198 1508 DC319FE5 		ldr	r3, .L136+44
 2199 150c 003093E5 		ldr	r3, [r3, #0]
 2200 1510 000053E3 		cmp	r3, #0
 2201 1514 2800000A 		beq	.L125
 931:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2202              		.loc 1 931 0 is_stmt 0 discriminator 2
 2203 1518 08301BE5 		ldr	r3, [fp, #-8]
 2204 151c 000053E3 		cmp	r3, #0
 2205 1520 2500001A 		bne	.L125
 931:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2206              		.loc 1 931 0 discriminator 1
 2207 1524 25305BE5 		ldrb	r3, [fp, #-37]	@ zero_extendqisi2
 2208 1528 000053E3 		cmp	r3, #0
 2209 152c EDFFFF0A 		beq	.L126
 931:../cyfxbulksrcsink.c ****             while ((glForceLinkU2) && (stat == CY_U3P_SUCCESS) && (curState == CyU3PUsbLPM_U0))
 2210              		.loc 1 931 0
 2211 1530 210000EA 		b	.L125
 2212              	.L123:
 937:../cyfxbulksrcsink.c ****             }
 938:../cyfxbulksrcsink.c ****         }
 939:../cyfxbulksrcsink.c ****         else
 940:../cyfxbulksrcsink.c ****         {
 941:../cyfxbulksrcsink.c **** 
 942:../cyfxbulksrcsink.c ****             /* Once data transfer has started, we keep trying to get the USB link to stay in U0. If
 943:../cyfxbulksrcsink.c ****                before data transfers have started, there is a likelihood of failing the TD 9.24 U1/
 944:../cyfxbulksrcsink.c ****             if ((CyU3PUsbGetSpeed () == CY_U3P_SUPER_SPEED) && (glDataTransStarted))
 2213              		.loc 1 944 0 is_stmt 1
 2214 1534 FEFFFFEB 		bl	CyU3PUsbGetSpeed
 2215 1538 0030A0E1 		mov	r3, r0
 2216 153c 030053E3 		cmp	r3, #3
 2217 1540 1D00001A 		bne	.L125
 2218              		.loc 1 944 0 is_stmt 0 discriminator 1
 2219 1544 A4319FE5 		ldr	r3, .L136+48
 2220 1548 003093E5 		ldr	r3, [r3, #0]
 2221 154c 000053E3 		cmp	r3, #0
 2222 1550 1900000A 		beq	.L125
 945:../cyfxbulksrcsink.c ****             {
 946:../cyfxbulksrcsink.c ****                 /* If the link is in U1/U2 states, try to get back to U0. */
 947:../cyfxbulksrcsink.c ****                 stat = CyU3PUsbGetLinkPowerState (&curState);
 2223              		.loc 1 947 0 is_stmt 1
 2224 1554 25304BE2 		sub	r3, fp, #37
 2225 1558 0300A0E1 		mov	r0, r3
 2226 155c FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2227 1560 08000BE5 		str	r0, [fp, #-8]
 948:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2228              		.loc 1 948 0
 2229 1564 070000EA 		b	.L127
 2230              	.L128:
 949:../cyfxbulksrcsink.c ****                         (glDataTransStarted))
 950:../cyfxbulksrcsink.c ****                 {
 951:../cyfxbulksrcsink.c ****                     CyU3PUsbSetLinkPowerState (CyU3PUsbLPM_U0);
 2231              		.loc 1 951 0
 2232 1568 0000A0E3 		mov	r0, #0
 2233 156c FEFFFFEB 		bl	CyU3PUsbSetLinkPowerState
 952:../cyfxbulksrcsink.c ****                     CyU3PThreadSleep (1);
 2234              		.loc 1 952 0
 2235 1570 0100A0E3 		mov	r0, #1
 2236 1574 FEFFFFEB 		bl	_tx_thread_sleep
 953:../cyfxbulksrcsink.c ****                     stat = CyU3PUsbGetLinkPowerState (&curState);
 2237              		.loc 1 953 0
 2238 1578 25304BE2 		sub	r3, fp, #37
 2239 157c 0300A0E1 		mov	r0, r3
 2240 1580 FEFFFFEB 		bl	CyU3PUsbGetLinkPowerState
 2241 1584 08000BE5 		str	r0, [fp, #-8]
 2242              	.L127:
 948:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2243              		.loc 1 948 0 discriminator 1
 2244 1588 08301BE5 		ldr	r3, [fp, #-8]
 2245 158c 000053E3 		cmp	r3, #0
 2246 1590 0900001A 		bne	.L125
 948:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2247              		.loc 1 948 0 is_stmt 0 discriminator 2
 2248 1594 25305BE5 		ldrb	r3, [fp, #-37]	@ zero_extendqisi2
 2249 1598 000053E3 		cmp	r3, #0
 2250 159c 0600000A 		beq	.L125
 948:../cyfxbulksrcsink.c ****                 while ((stat == CY_U3P_SUCCESS) && (curState >= CyU3PUsbLPM_U1) && (curState <= CyU
 2251              		.loc 1 948 0 discriminator 1
 2252 15a0 25305BE5 		ldrb	r3, [fp, #-37]	@ zero_extendqisi2
 2253 15a4 030053E3 		cmp	r3, #3
 2254 15a8 0300008A 		bhi	.L125
 2255 15ac 3C319FE5 		ldr	r3, .L136+48
 2256 15b0 003093E5 		ldr	r3, [r3, #0]
 2257 15b4 000053E3 		cmp	r3, #0
 2258 15b8 EAFFFF1A 		bne	.L128
 2259              	.L125:
 954:../cyfxbulksrcsink.c ****                 }
 955:../cyfxbulksrcsink.c ****             }
 956:../cyfxbulksrcsink.c ****         }
 957:../cyfxbulksrcsink.c **** 
 958:../cyfxbulksrcsink.c ****         if (TriggerStandbyMode)
 2260              		.loc 1 958 0 is_stmt 1
 2261 15bc 30319FE5 		ldr	r3, .L136+52
 2262 15c0 003093E5 		ldr	r3, [r3, #0]
 2263 15c4 000053E3 		cmp	r3, #0
 2264 15c8 1A00000A 		beq	.L129
 959:../cyfxbulksrcsink.c ****         {
 960:../cyfxbulksrcsink.c ****             TriggerStandbyMode = CyFalse;
 2265              		.loc 1 960 0
 2266 15cc 20319FE5 		ldr	r3, .L136+52
 2267 15d0 0020A0E3 		mov	r2, #0
 2268 15d4 002083E5 		str	r2, [r3, #0]
 961:../cyfxbulksrcsink.c **** 
 962:../cyfxbulksrcsink.c ****             CyU3PConnectState (CyFalse, CyTrue);
 2269              		.loc 1 962 0
 2270 15d8 0000A0E3 		mov	r0, #0
 2271 15dc 0110A0E3 		mov	r1, #1
 2272 15e0 FEFFFFEB 		bl	CyU3PConnectState
 963:../cyfxbulksrcsink.c ****             CyU3PUsbStop ();
 2273              		.loc 1 963 0
 2274 15e4 FEFFFFEB 		bl	CyU3PUsbStop
 964:../cyfxbulksrcsink.c ****             CyU3PDebugDeInit ();
 2275              		.loc 1 964 0
 2276 15e8 FEFFFFEB 		bl	CyU3PDebugDeInit
 965:../cyfxbulksrcsink.c ****             CyU3PUartDeInit ();
 2277              		.loc 1 965 0
 2278 15ec FEFFFFEB 		bl	CyU3PUartDeInit
 966:../cyfxbulksrcsink.c **** 
 967:../cyfxbulksrcsink.c ****             /* VBus has been turned off. Go into standby mode and wait for VBus to be turned on aga
 968:../cyfxbulksrcsink.c ****                The I-TCM content and GPIO register state will be backed up in the memory area start
 969:../cyfxbulksrcsink.c ****                at address 0x40060000. */
 970:../cyfxbulksrcsink.c ****             stat = CyU3PSysEnterStandbyMode (CY_U3P_SYS_USB_VBUS_WAKEUP_SRC, CY_U3P_SYS_USB_VBUS_WA
 2279              		.loc 1 970 0
 2280 15f0 0400A0E3 		mov	r0, #4
 2281 15f4 0410A0E3 		mov	r1, #4
 2282 15f8 F8209FE5 		ldr	r2, .L136+56
 2283 15fc FEFFFFEB 		bl	CyU3PSysEnterStandbyMode
 2284 1600 08000BE5 		str	r0, [fp, #-8]
 971:../cyfxbulksrcsink.c ****                     (uint8_t *)0x40060000);
 972:../cyfxbulksrcsink.c ****             if (stat != CY_U3P_SUCCESS)
 2285              		.loc 1 972 0
 2286 1604 08301BE5 		ldr	r3, [fp, #-8]
 2287 1608 000053E3 		cmp	r3, #0
 2288 160c 0600000A 		beq	.L130
 973:../cyfxbulksrcsink.c ****             {
 974:../cyfxbulksrcsink.c ****                 CyFxBulkSrcSinkApplnDebugInit ();
 2289              		.loc 1 974 0
 2290 1610 FEFFFFEB 		bl	CyFxBulkSrcSinkApplnDebugInit
 975:../cyfxbulksrcsink.c ****                 CyU3PDebugPrint (4, "Enter standby returned %d\r\n", stat);
 2291              		.loc 1 975 0
 2292 1614 0400A0E3 		mov	r0, #4
 2293 1618 DC109FE5 		ldr	r1, .L136+60
 2294 161c 08201BE5 		ldr	r2, [fp, #-8]
 2295 1620 FEFFFFEB 		bl	CyU3PDebugPrint
 976:../cyfxbulksrcsink.c ****                 CyFxAppErrorHandler (stat);
 2296              		.loc 1 976 0
 2297 1624 08001BE5 		ldr	r0, [fp, #-8]
 2298 1628 FEFFFFEB 		bl	CyFxAppErrorHandler
 2299              	.L130:
 977:../cyfxbulksrcsink.c ****             }
 978:../cyfxbulksrcsink.c **** 
 979:../cyfxbulksrcsink.c ****             /* If the entry into standby succeeds, the CyU3PSysEnterStandbyMode function never retu
 980:../cyfxbulksrcsink.c ****                firmware application starts running again from the main entry point. Therefore, this
 981:../cyfxbulksrcsink.c ****                will never be executed. */
 982:../cyfxbulksrcsink.c ****             CyFxAppErrorHandler (1);
 2300              		.loc 1 982 0
 2301 162c 0100A0E3 		mov	r0, #1
 2302 1630 FEFFFFEB 		bl	CyFxAppErrorHandler
 983:../cyfxbulksrcsink.c ****         }
 984:../cyfxbulksrcsink.c ****         else
 985:../cyfxbulksrcsink.c ****         {
 986:../cyfxbulksrcsink.c ****             /* Compare the current USB driver log index against the previous value. */
 987:../cyfxbulksrcsink.c ****             tmp1 = CyU3PUsbGetEventLogIndex ();
 988:../cyfxbulksrcsink.c ****             if (tmp1 != prevUsbLogIndex)
 989:../cyfxbulksrcsink.c ****             {
 990:../cyfxbulksrcsink.c ****                 tmp2 = prevUsbLogIndex;
 991:../cyfxbulksrcsink.c ****                 while (tmp2 != tmp1)
 992:../cyfxbulksrcsink.c ****                 {
 993:../cyfxbulksrcsink.c ****                     CyU3PDebugPrint (4, "USB LOG: %x\r\n", gl_UsbLogBuffer[tmp2]);
 994:../cyfxbulksrcsink.c ****                     tmp2++;
 995:../cyfxbulksrcsink.c ****                     if (tmp2 == CYFX_USBLOG_SIZE)
 996:../cyfxbulksrcsink.c ****                         tmp2 = 0;
 997:../cyfxbulksrcsink.c ****                 }
 998:../cyfxbulksrcsink.c ****             }
 999:../cyfxbulksrcsink.c **** 
1000:../cyfxbulksrcsink.c ****             /* Store the current log index. */
1001:../cyfxbulksrcsink.c ****             prevUsbLogIndex = tmp1;
1002:../cyfxbulksrcsink.c ****         }
1003:../cyfxbulksrcsink.c ****     }
 2303              		.loc 1 1003 0
 2304 1634 59FEFFEA 		b	.L135
 2305              	.L129:
 987:../cyfxbulksrcsink.c ****             tmp1 = CyU3PUsbGetEventLogIndex ();
 2306              		.loc 1 987 0
 2307 1638 FEFFFFEB 		bl	CyU3PUsbGetEventLogIndex
 2308 163c 0030A0E1 		mov	r3, r0
 2309 1640 BE314BE1 		strh	r3, [fp, #-30]	@ movhi
 988:../cyfxbulksrcsink.c ****             if (tmp1 != prevUsbLogIndex)
 2310              		.loc 1 988 0
 2311 1644 BE215BE1 		ldrh	r2, [fp, #-30]
 2312 1648 BA305BE1 		ldrh	r3, [fp, #-10]
 2313 164c 030052E1 		cmp	r2, r3
 2314 1650 1700000A 		beq	.L132
 990:../cyfxbulksrcsink.c ****                 tmp2 = prevUsbLogIndex;
 2315              		.loc 1 990 0
 2316 1654 BA305BE1 		ldrh	r3, [fp, #-10]	@ movhi
 2317 1658 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
 991:../cyfxbulksrcsink.c ****                 while (tmp2 != tmp1)
 2318              		.loc 1 991 0
 2319 165c 100000EA 		b	.L133
 2320              	.L134:
 993:../cyfxbulksrcsink.c ****                     CyU3PDebugPrint (4, "USB LOG: %x\r\n", gl_UsbLogBuffer[tmp2]);
 2321              		.loc 1 993 0
 2322 1660 78309FE5 		ldr	r3, .L136+32
 2323 1664 002093E5 		ldr	r2, [r3, #0]
 2324 1668 BC305BE1 		ldrh	r3, [fp, #-12]
 2325 166c 033082E0 		add	r3, r2, r3
 2326 1670 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 2327 1674 0400A0E3 		mov	r0, #4
 2328 1678 80109FE5 		ldr	r1, .L136+64
 2329 167c 0320A0E1 		mov	r2, r3
 2330 1680 FEFFFFEB 		bl	CyU3PDebugPrint
 994:../cyfxbulksrcsink.c ****                     tmp2++;
 2331              		.loc 1 994 0
 2332 1684 BC305BE1 		ldrh	r3, [fp, #-12]	@ movhi
 2333 1688 013083E2 		add	r3, r3, #1
 2334 168c BC304BE1 		strh	r3, [fp, #-12]	@ movhi
 995:../cyfxbulksrcsink.c ****                     if (tmp2 == CYFX_USBLOG_SIZE)
 2335              		.loc 1 995 0
 2336 1690 BC305BE1 		ldrh	r3, [fp, #-12]
 2337 1694 010A53E3 		cmp	r3, #4096
 2338 1698 0100001A 		bne	.L133
 996:../cyfxbulksrcsink.c ****                         tmp2 = 0;
 2339              		.loc 1 996 0
 2340 169c 0030A0E3 		mov	r3, #0
 2341 16a0 BC304BE1 		strh	r3, [fp, #-12]	@ movhi
 2342              	.L133:
 991:../cyfxbulksrcsink.c ****                 while (tmp2 != tmp1)
 2343              		.loc 1 991 0 discriminator 1
 2344 16a4 BC205BE1 		ldrh	r2, [fp, #-12]
 2345 16a8 BE315BE1 		ldrh	r3, [fp, #-30]
 2346 16ac 030052E1 		cmp	r2, r3
 2347 16b0 EAFFFF1A 		bne	.L134
 2348              	.L132:
1001:../cyfxbulksrcsink.c ****             prevUsbLogIndex = tmp1;
 2349              		.loc 1 1001 0
 2350 16b4 BE315BE1 		ldrh	r3, [fp, #-30]	@ movhi
 2351 16b8 BA304BE1 		strh	r3, [fp, #-10]	@ movhi
 2352              		.loc 1 1003 0
 2353 16bc 37FEFFEA 		b	.L135
 2354              	.L137:
 2355              		.align	2
 2356              	.L136:
 2357 16c0 94030000 		.word	.LC19
 2358 16c4 00000000 		.word	glBulkLpEvent
 2359 16c8 AC030000 		.word	.LC20
 2360 16cc 00000000 		.word	gl_setupdat0
 2361 16d0 00000000 		.word	gl_setupdat1
 2362 16d4 00000000 		.word	glEp0StatCount
 2363 16d8 00000000 		.word	glEp0Buffer
 2364 16dc FF0F0000 		.word	4095
 2365 16e0 00000000 		.word	gl_UsbLogBuffer
 2366 16e4 00800740 		.word	1074233344
 2367 16e8 00000000 		.word	StandbyModeEnable
 2368 16ec 00000000 		.word	glForceLinkU2
 2369 16f0 00000000 		.word	glDataTransStarted
 2370 16f4 00000000 		.word	TriggerStandbyMode
 2371 16f8 00000640 		.word	1074135040
 2372 16fc D8030000 		.word	.LC21
 2373 1700 F4030000 		.word	.LC22
 2374              		.cfi_endproc
 2375              	.LFE9:
 2377              		.section	.rodata
 2378 0402 0000     		.align	2
 2379              	.LC23:
 2380 0404 32313A42 		.ascii	"21:Bulk_src_sink\000"
 2380      756C6B5F 
 2380      7372635F 
 2380      73696E6B 
 2380      00
 2381              		.text
 2382              		.align	2
 2383              		.global	CyFxApplicationDefine
 2385              	CyFxApplicationDefine:
 2386              	.LFB10:
1004:../cyfxbulksrcsink.c **** }
1005:../cyfxbulksrcsink.c **** 
1006:../cyfxbulksrcsink.c **** /* Application define function which creates the threads. */
1007:../cyfxbulksrcsink.c **** void
1008:../cyfxbulksrcsink.c **** CyFxApplicationDefine (
1009:../cyfxbulksrcsink.c ****         void)
1010:../cyfxbulksrcsink.c **** {
 2387              		.loc 1 1010 0
 2388              		.cfi_startproc
 2389              		@ args = 0, pretend = 0, frame = 8
 2390              		@ frame_needed = 1, uses_anonymous_args = 0
 2391 1704 00482DE9 		stmfd	sp!, {fp, lr}
 2392              	.LCFI20:
 2393              		.cfi_def_cfa_offset 8
 2394 1708 04B08DE2 		add	fp, sp, #4
 2395              		.cfi_offset 14, -4
 2396              		.cfi_offset 11, -8
 2397              	.LCFI21:
 2398              		.cfi_def_cfa 11, 4
 2399 170c 28D04DE2 		sub	sp, sp, #40
1011:../cyfxbulksrcsink.c ****     void *ptr = NULL;
 2400              		.loc 1 1011 0
 2401 1710 0030A0E3 		mov	r3, #0
 2402 1714 08300BE5 		str	r3, [fp, #-8]
1012:../cyfxbulksrcsink.c ****     uint32_t ret = CY_U3P_SUCCESS;
 2403              		.loc 1 1012 0
 2404 1718 0030A0E3 		mov	r3, #0
 2405 171c 0C300BE5 		str	r3, [fp, #-12]
1013:../cyfxbulksrcsink.c **** 
1014:../cyfxbulksrcsink.c ****     /* Create an event flag group that will be used for signalling the application thread. */
1015:../cyfxbulksrcsink.c ****     ret = CyU3PEventCreate (&glBulkLpEvent);
 2406              		.loc 1 1015 0
 2407 1720 90009FE5 		ldr	r0, .L143
 2408 1724 0010A0E3 		mov	r1, #0
 2409 1728 2820A0E3 		mov	r2, #40
 2410 172c FEFFFFEB 		bl	_txe_event_flags_create
 2411 1730 0C000BE5 		str	r0, [fp, #-12]
1016:../cyfxbulksrcsink.c ****     if (ret != 0)
 2412              		.loc 1 1016 0
 2413 1734 0C301BE5 		ldr	r3, [fp, #-12]
 2414 1738 000053E3 		cmp	r3, #0
 2415 173c 0000000A 		beq	.L139
 2416              	.L140:
1017:../cyfxbulksrcsink.c ****     {
1018:../cyfxbulksrcsink.c ****         /* Loop indefinitely */
1019:../cyfxbulksrcsink.c ****         while (1);
 2417              		.loc 1 1019 0 discriminator 1
 2418 1740 FEFFFFEA 		b	.L140
 2419              	.L139:
1020:../cyfxbulksrcsink.c ****     }
1021:../cyfxbulksrcsink.c **** 
1022:../cyfxbulksrcsink.c ****     /* Allocate the memory for the threads */
1023:../cyfxbulksrcsink.c ****     ptr = CyU3PMemAlloc (CY_FX_BULKSRCSINK_THREAD_STACK);
 2420              		.loc 1 1023 0
 2421 1744 010AA0E3 		mov	r0, #4096
 2422 1748 FEFFFFEB 		bl	CyU3PMemAlloc
 2423 174c 08000BE5 		str	r0, [fp, #-8]
1024:../cyfxbulksrcsink.c **** 
1025:../cyfxbulksrcsink.c ****     /* Create the thread for the application */
1026:../cyfxbulksrcsink.c ****     ret = CyU3PThreadCreate (&bulkSrcSinkAppThread,                /* App thread structure */
 2424              		.loc 1 1026 0
 2425 1750 08301BE5 		ldr	r3, [fp, #-8]
 2426 1754 00308DE5 		str	r3, [sp, #0]
 2427 1758 013AA0E3 		mov	r3, #4096
 2428 175c 04308DE5 		str	r3, [sp, #4]
 2429 1760 0830A0E3 		mov	r3, #8
 2430 1764 08308DE5 		str	r3, [sp, #8]
 2431 1768 0830A0E3 		mov	r3, #8
 2432 176c 0C308DE5 		str	r3, [sp, #12]
 2433 1770 0030A0E3 		mov	r3, #0
 2434 1774 10308DE5 		str	r3, [sp, #16]
 2435 1778 0130A0E3 		mov	r3, #1
 2436 177c 14308DE5 		str	r3, [sp, #20]
 2437 1780 A830A0E3 		mov	r3, #168
 2438 1784 18308DE5 		str	r3, [sp, #24]
 2439 1788 2C009FE5 		ldr	r0, .L143+4
 2440 178c 2C109FE5 		ldr	r1, .L143+8
 2441 1790 2C209FE5 		ldr	r2, .L143+12
 2442 1794 0030A0E3 		mov	r3, #0
 2443 1798 FEFFFFEB 		bl	_txe_thread_create
 2444 179c 0C000BE5 		str	r0, [fp, #-12]
1027:../cyfxbulksrcsink.c ****                           "21:Bulk_src_sink",                      /* Thread ID and thread name */
1028:../cyfxbulksrcsink.c ****                           BulkSrcSinkAppThread_Entry,              /* App thread entry function */
1029:../cyfxbulksrcsink.c ****                           0,                                       /* No input parameter to thread 
1030:../cyfxbulksrcsink.c ****                           ptr,                                     /* Pointer to the allocated thre
1031:../cyfxbulksrcsink.c ****                           CY_FX_BULKSRCSINK_THREAD_STACK,          /* App thread stack size */
1032:../cyfxbulksrcsink.c ****                           CY_FX_BULKSRCSINK_THREAD_PRIORITY,       /* App thread priority */
1033:../cyfxbulksrcsink.c ****                           CY_FX_BULKSRCSINK_THREAD_PRIORITY,       /* App thread priority */
1034:../cyfxbulksrcsink.c ****                           CYU3P_NO_TIME_SLICE,                     /* No time slice for the applica
1035:../cyfxbulksrcsink.c ****                           CYU3P_AUTO_START                         /* Start the thread immediately 
1036:../cyfxbulksrcsink.c ****                           );
1037:../cyfxbulksrcsink.c **** 
1038:../cyfxbulksrcsink.c ****     /* Check the return code */
1039:../cyfxbulksrcsink.c ****     if (ret != 0)
 2445              		.loc 1 1039 0
 2446 17a0 0C301BE5 		ldr	r3, [fp, #-12]
 2447 17a4 000053E3 		cmp	r3, #0
 2448 17a8 0000000A 		beq	.L138
 2449              	.L142:
1040:../cyfxbulksrcsink.c ****     {
1041:../cyfxbulksrcsink.c ****         /* Thread Creation failed with the error code retThrdCreate */
1042:../cyfxbulksrcsink.c **** 
1043:../cyfxbulksrcsink.c ****         /* Add custom recovery or debug actions here */
1044:../cyfxbulksrcsink.c **** 
1045:../cyfxbulksrcsink.c ****         /* Application cannot continue */
1046:../cyfxbulksrcsink.c ****         /* Loop indefinitely */
1047:../cyfxbulksrcsink.c ****         while(1);
 2450              		.loc 1 1047 0 discriminator 1
 2451 17ac FEFFFFEA 		b	.L142
 2452              	.L138:
1048:../cyfxbulksrcsink.c ****     }
1049:../cyfxbulksrcsink.c **** }
 2453              		.loc 1 1049 0
 2454 17b0 04D04BE2 		sub	sp, fp, #4
 2455 17b4 0088BDE8 		ldmfd	sp!, {fp, pc}
 2456              	.L144:
 2457              		.align	2
 2458              	.L143:
 2459 17b8 00000000 		.word	glBulkLpEvent
 2460 17bc 00000000 		.word	bulkSrcSinkAppThread
 2461 17c0 04040000 		.word	.LC23
 2462 17c4 00000000 		.word	BulkSrcSinkAppThread_Entry
 2463              		.cfi_endproc
 2464              	.LFE10:
 2466              		.align	2
 2467              		.global	main
 2469              	main:
 2470              	.LFB11:
1050:../cyfxbulksrcsink.c **** 
1051:../cyfxbulksrcsink.c **** /*
1052:../cyfxbulksrcsink.c ****  * Main function
1053:../cyfxbulksrcsink.c ****  */
1054:../cyfxbulksrcsink.c **** int
1055:../cyfxbulksrcsink.c **** main (void)
1056:../cyfxbulksrcsink.c **** {
 2471              		.loc 1 1056 0
 2472              		.cfi_startproc
 2473              		@ args = 0, pretend = 0, frame = 64
 2474              		@ frame_needed = 1, uses_anonymous_args = 0
 2475 17c8 00482DE9 		stmfd	sp!, {fp, lr}
 2476              	.LCFI22:
 2477              		.cfi_def_cfa_offset 8
 2478 17cc 04B08DE2 		add	fp, sp, #4
 2479              		.cfi_offset 14, -4
 2480              		.cfi_offset 11, -8
 2481              	.LCFI23:
 2482              		.cfi_def_cfa 11, 4
 2483 17d0 40D04DE2 		sub	sp, sp, #64
1057:../cyfxbulksrcsink.c ****     CyU3PIoMatrixConfig_t io_cfg;
1058:../cyfxbulksrcsink.c ****     CyU3PReturnStatus_t status = CY_U3P_SUCCESS;
 2484              		.loc 1 1058 0
 2485 17d4 0030A0E3 		mov	r3, #0
 2486 17d8 08300BE5 		str	r3, [fp, #-8]
1059:../cyfxbulksrcsink.c **** 
1060:../cyfxbulksrcsink.c ****     /* Initialize the device */
1061:../cyfxbulksrcsink.c ****     CyU3PSysClockConfig_t clockConfig;
1062:../cyfxbulksrcsink.c ****     clockConfig.setSysClk400  = CyTrue;
 2487              		.loc 1 1062 0
 2488 17dc 0130A0E3 		mov	r3, #1
 2489 17e0 40300BE5 		str	r3, [fp, #-64]
1063:../cyfxbulksrcsink.c ****     clockConfig.cpuClkDiv     = 2;
 2490              		.loc 1 1063 0
 2491 17e4 0230A0E3 		mov	r3, #2
 2492 17e8 3C304BE5 		strb	r3, [fp, #-60]
1064:../cyfxbulksrcsink.c ****     clockConfig.dmaClkDiv     = 2;
 2493              		.loc 1 1064 0
 2494 17ec 0230A0E3 		mov	r3, #2
 2495 17f0 3B304BE5 		strb	r3, [fp, #-59]
1065:../cyfxbulksrcsink.c ****     clockConfig.mmioClkDiv    = 2;
 2496              		.loc 1 1065 0
 2497 17f4 0230A0E3 		mov	r3, #2
 2498 17f8 3A304BE5 		strb	r3, [fp, #-58]
1066:../cyfxbulksrcsink.c ****     clockConfig.useStandbyClk = CyFalse;
 2499              		.loc 1 1066 0
 2500 17fc 0030A0E3 		mov	r3, #0
 2501 1800 38300BE5 		str	r3, [fp, #-56]
1067:../cyfxbulksrcsink.c ****     clockConfig.clkSrc         = CY_U3P_SYS_CLK;
 2502              		.loc 1 1067 0
 2503 1804 0330A0E3 		mov	r3, #3
 2504 1808 34304BE5 		strb	r3, [fp, #-52]
1068:../cyfxbulksrcsink.c ****     status = CyU3PDeviceInit (&clockConfig);
 2505              		.loc 1 1068 0
 2506 180c 40304BE2 		sub	r3, fp, #64
 2507 1810 0300A0E1 		mov	r0, r3
 2508 1814 FEFFFFEB 		bl	CyU3PDeviceInit
 2509 1818 08000BE5 		str	r0, [fp, #-8]
1069:../cyfxbulksrcsink.c ****     if (status != CY_U3P_SUCCESS)
 2510              		.loc 1 1069 0
 2511 181c 08301BE5 		ldr	r3, [fp, #-8]
 2512 1820 000053E3 		cmp	r3, #0
 2513 1824 0000000A 		beq	.L146
1070:../cyfxbulksrcsink.c ****     {
1071:../cyfxbulksrcsink.c ****         goto handle_fatal_error;
 2514              		.loc 1 1071 0
 2515 1828 290000EA 		b	.L147
 2516              	.L146:
1072:../cyfxbulksrcsink.c ****     }
1073:../cyfxbulksrcsink.c **** 
1074:../cyfxbulksrcsink.c ****     /* Initialize the caches. Enable both Instruction and Data caches. */
1075:../cyfxbulksrcsink.c ****     status = CyU3PDeviceCacheControl (CyTrue, CyFalse, CyFalse);	//mddd
 2517              		.loc 1 1075 0
 2518 182c 0100A0E3 		mov	r0, #1
 2519 1830 0010A0E3 		mov	r1, #0
 2520 1834 0020A0E3 		mov	r2, #0
 2521 1838 FEFFFFEB 		bl	CyU3PDeviceCacheControl
 2522 183c 08000BE5 		str	r0, [fp, #-8]
1076:../cyfxbulksrcsink.c ****     if (status != CY_U3P_SUCCESS)
 2523              		.loc 1 1076 0
 2524 1840 08301BE5 		ldr	r3, [fp, #-8]
 2525 1844 000053E3 		cmp	r3, #0
 2526 1848 0000000A 		beq	.L148
1077:../cyfxbulksrcsink.c ****     {
1078:../cyfxbulksrcsink.c ****         goto handle_fatal_error;
 2527              		.loc 1 1078 0
 2528 184c 200000EA 		b	.L147
 2529              	.L148:
1079:../cyfxbulksrcsink.c ****     }
1080:../cyfxbulksrcsink.c **** 
1081:../cyfxbulksrcsink.c ****     /* Configure the IO matrix for the device. On the FX3 DVK board, the COM port 
1082:../cyfxbulksrcsink.c ****      * is connected to the IO(53:56). This means that either DQ32 mode should be
1083:../cyfxbulksrcsink.c ****      * selected or lppMode should be set to UART_ONLY. Here we are choosing
1084:../cyfxbulksrcsink.c ****      * UART_ONLY configuration. */
1085:../cyfxbulksrcsink.c ****     io_cfg.isDQ32Bit = CyFalse;
 2530              		.loc 1 1085 0
 2531 1850 0030A0E3 		mov	r3, #0
 2532 1854 30300BE5 		str	r3, [fp, #-48]
1086:../cyfxbulksrcsink.c ****     io_cfg.useUart   = CyTrue;
 2533              		.loc 1 1086 0
 2534 1858 0130A0E3 		mov	r3, #1
 2535 185c 2C300BE5 		str	r3, [fp, #-44]
1087:../cyfxbulksrcsink.c ****     io_cfg.useI2C    = CyFalse;
 2536              		.loc 1 1087 0
 2537 1860 0030A0E3 		mov	r3, #0
 2538 1864 28300BE5 		str	r3, [fp, #-40]
1088:../cyfxbulksrcsink.c ****     io_cfg.useI2S    = CyFalse;
 2539              		.loc 1 1088 0
 2540 1868 0030A0E3 		mov	r3, #0
 2541 186c 24300BE5 		str	r3, [fp, #-36]
1089:../cyfxbulksrcsink.c ****     io_cfg.useSpi    = CyFalse;
 2542              		.loc 1 1089 0
 2543 1870 0030A0E3 		mov	r3, #0
 2544 1874 20300BE5 		str	r3, [fp, #-32]
1090:../cyfxbulksrcsink.c ****     io_cfg.lppMode   = CY_U3P_IO_MATRIX_LPP_UART_ONLY;
 2545              		.loc 1 1090 0
 2546 1878 0130A0E3 		mov	r3, #1
 2547 187c 1C304BE5 		strb	r3, [fp, #-28]
1091:../cyfxbulksrcsink.c **** 
1092:../cyfxbulksrcsink.c ****     /* No GPIOs are enabled. */
1093:../cyfxbulksrcsink.c ****     io_cfg.gpioSimpleEn[0]  = 0;
 2548              		.loc 1 1093 0
 2549 1880 0030A0E3 		mov	r3, #0
 2550 1884 18300BE5 		str	r3, [fp, #-24]
1094:../cyfxbulksrcsink.c ****     io_cfg.gpioSimpleEn[1]  = FX3_GPIO_TO_HIFLAG(FX3_GPIO_TEST_OUT);
 2551              		.loc 1 1094 0
 2552 1888 0137A0E3 		mov	r3, #262144
 2553 188c 14300BE5 		str	r3, [fp, #-20]
1095:../cyfxbulksrcsink.c ****     io_cfg.gpioComplexEn[0] = 0;
 2554              		.loc 1 1095 0
 2555 1890 0030A0E3 		mov	r3, #0
 2556 1894 10300BE5 		str	r3, [fp, #-16]
1096:../cyfxbulksrcsink.c ****     io_cfg.gpioComplexEn[1] = 0;
 2557              		.loc 1 1096 0
 2558 1898 0030A0E3 		mov	r3, #0
 2559 189c 0C300BE5 		str	r3, [fp, #-12]
1097:../cyfxbulksrcsink.c ****     status = CyU3PDeviceConfigureIOMatrix (&io_cfg);
 2560              		.loc 1 1097 0
 2561 18a0 30304BE2 		sub	r3, fp, #48
 2562 18a4 0300A0E1 		mov	r0, r3
 2563 18a8 FEFFFFEB 		bl	CyU3PDeviceConfigureIOMatrix
 2564 18ac 08000BE5 		str	r0, [fp, #-8]
1098:../cyfxbulksrcsink.c ****     if (status != CY_U3P_SUCCESS)
 2565              		.loc 1 1098 0
 2566 18b0 08301BE5 		ldr	r3, [fp, #-8]
 2567 18b4 000053E3 		cmp	r3, #0
 2568 18b8 0000000A 		beq	.L149
1099:../cyfxbulksrcsink.c ****     {
1100:../cyfxbulksrcsink.c ****         goto handle_fatal_error;
 2569              		.loc 1 1100 0
 2570 18bc 040000EA 		b	.L147
 2571              	.L149:
1101:../cyfxbulksrcsink.c ****     }
1102:../cyfxbulksrcsink.c **** 
1103:../cyfxbulksrcsink.c ****     /* This is a non returnable call for initializing the RTOS kernel */
1104:../cyfxbulksrcsink.c ****     CyU3PKernelEntry ();
 2572              		.loc 1 1104 0
 2573 18c0 FEFFFFEB 		bl	_tx_initialize_kernel_enter
1105:../cyfxbulksrcsink.c **** 
1106:../cyfxbulksrcsink.c ****     /* Dummy return to make the compiler happy */
1107:../cyfxbulksrcsink.c ****     return 0;
 2574              		.loc 1 1107 0
 2575 18c4 0030A0E3 		mov	r3, #0
1108:../cyfxbulksrcsink.c **** 
1109:../cyfxbulksrcsink.c **** handle_fatal_error:
1110:../cyfxbulksrcsink.c **** 
1111:../cyfxbulksrcsink.c ****     /* Cannot recover from this error. */
1112:../cyfxbulksrcsink.c ****     while (1);
1113:../cyfxbulksrcsink.c **** }
 2576              		.loc 1 1113 0
 2577 18c8 0300A0E1 		mov	r0, r3
 2578 18cc 04D04BE2 		sub	sp, fp, #4
 2579 18d0 0088BDE8 		ldmfd	sp!, {fp, pc}
 2580              	.L147:
1112:../cyfxbulksrcsink.c ****     while (1);
 2581              		.loc 1 1112 0 discriminator 1
 2582 18d4 FEFFFFEA 		b	.L147
 2583              		.cfi_endproc
 2584              	.LFE11:
 2586              		.bss
 2587              		.align	2
 2588              	num_connect.6776:
 2589 0024 00000000 		.space	4
 2590              		.align	2
 2591              	num_disconnect.6777:
 2592 0028 00000000 		.space	4
 2593              		.section	.rodata
 2594 0415 000000   		.align	2
 2597              	C.57.8416:
 2598 0418 01000000 		.word	1
 2599 041c 01000000 		.word	1
 2600 0420 01000000 		.word	1
 2601 0424 00000000 		.word	0
 2602 0428 00       		.byte	0
 2603 0429 000000   		.space	3
 2604              		.text
 2605              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 cyfxbulksrcsink.c
                            *COM*:000000a8 bulkSrcSinkAppThread
                            *COM*:000000a0 glChHandleBulkSink
                            *COM*:000000a0 glChHandleBulkSrc
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:29     .bss:00000000 glIsApplnActive
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:26     .bss:00000000 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:35     .bss:00000004 glDMARxCount
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:41     .bss:00000008 glDMATxCount
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:47     .bss:0000000c glDataTransStarted
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:53     .bss:00000010 StandbyModeEnable
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:59     .bss:00000014 TriggerStandbyMode
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:65     .bss:00000018 glForceLinkU2
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:71     .bss:0000001c glEp0StatCount
                            *COM*:00000020 glEp0Buffer
                            *COM*:00000028 glBulkLpEvent
                            *COM*:00000004 gl_setupdat0
                            *COM*:00000004 gl_setupdat1
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:81     .bss:00000020 gl_UsbLogBuffer
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:84     .text:00000000 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:87     .text:00000000 CyFxAppErrorHandler
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:116    .text:0000001c CyFxBulkSrcSinkApplnDebugInit
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:278    .text:000001b8 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2597   .rodata:00000418 C.57.8416
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:284    .rodata:00000000 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:297    .text:000001c0 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:300    .text:000001c0 CyFxBulkSrcSinkDmaCallback
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:403    .text:000002cc $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:426    .text:000002e4 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:429    .text:000002e4 CyFxBulkSrcSinkApplnStart
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:763    .text:00000668 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:779    .text:0000069c $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:782    .text:0000069c CyFxBulkSrcSinkApplnStop
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:869    .text:00000770 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:876    .text:00000780 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:879    .text:00000780 CyFxBulkSrcSinkApplnUSBSetupCB
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1095   .text:000009c0 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1114   .text:000009e0 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1117   .text:000009e0 CyFxBulkSrcSinkApplnUSBEventCB
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1142   .text:00000a0c $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1157   .text:00000a40 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1263   .text:00000b54 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2588   .bss:00000024 num_connect.6776
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2591   .bss:00000028 num_disconnect.6777
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1276   .text:00000b7c $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1279   .text:00000b7c CyFxBulkSrcSinkApplnLPMRqtCB
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1347   .text:00000ba4 CyFxBulkSrcSinkApplnInit
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1660   .text:00000f08 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1702   .text:00000f6c $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1705   .text:00000f6c BulkSrcSinkAppThread_Entry
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1829   .text:000010bc $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:1938   .text:00001268 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2357   .text:000016c0 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2382   .text:00001704 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2385   .text:00001704 CyFxApplicationDefine
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2459   .text:000017b8 $d
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2466   .text:000017c8 $a
C:\Users\nikl\AppData\Local\Temp\ccYetKpT.s:2469   .text:000017c8 main
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
_tx_thread_sleep
CyU3PGpioInit
CyU3PGpioSetSimpleConfig
CyU3PUartInit
CyU3PMemSet
CyU3PUartSetConfig
CyU3PUartTxSetBlockXfer
CyU3PDebugInit
CyU3PDebugPreamble
CyU3PDmaChannelDiscardBuffer
CyU3PDebugPrint
CyU3PDmaChannelGetBuffer
CyU3PDmaChannelCommitBuffer
CyU3PUsbGetSpeed
CyU3PSetEpConfig
CyU3PUsbFlushEp
CyU3PDmaChannelCreate
CyU3PDmaChannelSetXfer
CyU3PDmaChannelDestroy
CyU3PUsbAckSetup
CyU3PUsbStall
CyU3PDmaChannelReset
CyU3PUsbResetEp
_txe_event_flags_set
CyU3PUsbStart
CyU3PUsbRegisterSetupCallback
CyU3PUsbRegisterEventCallback
CyU3PUsbRegisterLPMRequestCallback
CyU3PUsbSetDesc
CyU3PDmaBufferAlloc
CyU3PUsbInitEventLog
CyU3PConnectState
CyFxUSB30DeviceDscr
CyFxUSB20DeviceDscr
CyFxUSBBOSDscr
CyFxUSBDeviceQualDscr
CyFxUSBSSConfigDscr
CyFxUSBHSConfigDscr
CyFxUSBFSConfigDscr
CyFxUSBStringLangIDDscr
CyFxUSBManufactureDscr
CyFxUSBProductDscr
_txe_event_flags_get
CyU3PUsbSendDevNotification
CyU3PUsbDoRemoteWakeup
CyU3PMemCopy
CyU3PUsbSendEP0Data
CyU3PUsbGetEP0Data
CyU3PUsbGetEventLogIndex
CyU3PReadDeviceRegisters
CyU3PUsbGetBooterVersion
CyU3PDebugDeInit
CyU3PUartDeInit
CyU3PUsbSetBooterSwitch
CyU3PUsbJumpBackToBooter
CyU3PDeviceReset
CyU3PUsbGetLinkPowerState
CyU3PUsbSetLinkPowerState
CyU3PUsbStop
CyU3PSysEnterStandbyMode
_txe_event_flags_create
CyU3PMemAlloc
_txe_thread_create
CyU3PDeviceInit
CyU3PDeviceCacheControl
CyU3PDeviceConfigureIOMatrix
_tx_initialize_kernel_enter
